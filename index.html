<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chameleon Ultra Amiibo Emulator</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        input[type="text"], input[type="number"], select {
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        #connect-btn {
            margin-bottom: 20px;
        }
        #amiibo-browser {
            width: 100%;
            max-width: 1200px;
            display: none;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        #search-filter-sort-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }
        #search-input {
            flex-grow: 1;
            margin-bottom: 0;
        }
        #amiibo-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .amiibo-card {
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }
        .amiibo-card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            transform: translateY(-2px);
        }
        .amiibo-card.selected {
            border-color: #007bff;
            background-color: #e7f3ff;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .amiibo-card img {
            max-width: 100px;
            max-height: 100px;
            display: block;
            margin: 0 auto 10px;
        }
        .amiibo-card p {
            font-size: 0.9em;
            font-weight: bold;
            color: #555;
            margin: 0;
        }
        /* Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto; /* Center the modal */
            padding: 20px;
            border: 1px solid #888;
            border-radius: 10px;
            width: 80%; /* Could be more responsive */
            max-width: 700px;
            box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
            animation-name: animatetop;
            animation-duration: 0.4s;
            display: flex; /* Use flex for inner content */
            flex-direction: column;
            gap: 20px;
        }
        /* Add Animation */
        @-webkit-keyframes animatetop {
            from {top: -300px; opacity: 0}
            to {top: 0; opacity: 1}
        }
        @keyframes animatetop {
            from {top: -300px; opacity: 0}
            to {top: 0; opacity: 1}
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        #amiibo-info-and-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px; /* Reduced gap */
            width: 100%;
            /* max-width: 1200px; */ /* Removed as it's now inside modal */
            margin-bottom: 0; /* Removed as it's now inside modal */
        }
        #amiibo-details {
            flex: 2 1 400px; /* Allows it to grow and shrink, min-width 400px */
            display: block; /* Always block inside modal */
            background-color: #fff;
            padding: 0; /* Padding handled by modal-content */
            border-radius: 8px;
            box-shadow: none; /* Shadow handled by modal-content */
            text-align: left;
        }
        #amiibo-details h3 {
            text-align: center;
            margin-top: 0;
        }
        #amiibo-details-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        #amiibo-details-image-container {
            flex: 1 1 150px;
            text-align: center;
        }
        #amiibo-details-image {
            max-width: 150px;
            height: auto;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        #amiibo-details-info {
            flex: 2 1 300px;
        }
        #amiibo-details-info p {
            margin: 5px 0;
            font-size: 1em;
        }
        #amiibo-details-info strong {
            color: #2c3e50;
        }
        #actions-container {
            flex: 1 1 300px; /* Allows it to grow and shrink, min-width 300px */
            display: block; /* Always block inside modal */
            background-color: #fff;
            padding: 0; /* Padding handled by modal-content */
            border-radius: 8px;
            box-shadow: none; /* Shadow handled by modal-content */
            text-align: center;
        }
        #status {
            margin-top: 15px;
            font-weight: bold;
            color: #555;
        }
        .status-success {
            color: #28a745;
        }
        .status-error {
            color: #dc3545;
        }
        #amiibo-slots {
            width: 100%;
            max-width: 1200px;
            display: none;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        #amiibo-slots-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
        }
        .slot-item {
            border: 1px solid #e0e0e0;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-size: 0.9em;
        }
        .amiibo-details.emulating {
            border: 2px solid #28a745; /* Green border for emulating */
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.5); /* Green glow */
        }

        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
            }
            #amiibo-list {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
            #search-filter-sort-container {
                flex-direction: column;
                align-items: stretch;
            }
            #amiibo-info-and-actions {
                flex-direction: column;
            }
            #amiibo-details-content {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <h1>Chameleon Ultra Amiibo Emulator</h1>
    <button id="connect-btn">Connect to Chameleon Ultra</button>

    <div id="amiibo-browser">
        <h2>Select an Amiibo</h2>
        <div id="search-filter-sort-container">
            <input type="text" id="search-input" placeholder="Search by name...">
            <select id="game-series-filter">
                <option value="">All Game Series</option>
            </select>
            <select id="amiibo-series-filter">
                <option value="">All Amiibo Series</option>
            </select>
            <select id="character-filter">
                <option value="">All Characters</option>
            </select>
            <select id="sort-by">
                <option value="name-asc">Name (A-Z)</option>
                <option value="name-desc">Name (Z-A)</option>
                <option value="release-na-asc">Release (NA) Oldest First</option>
                <option value="release-na-desc">Release (NA) Newest First</option>
            </select>
            <button id="clear-filters-sort">Clear</button>
        </div>
        <div id="amiibo-list"></div>
    </div>

    <div id="amiibo-slots">
        <h2>Amiibos in Slots</h2>
        <div id="amiibo-slots-list"></div>
    </div>

    <!-- The Modal -->
    <div id="amiiboModal" class="modal">
        <!-- Modal content -->
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <div id="amiibo-info-and-actions">
                <div id="amiibo-details">
                    <h3>Selected Amiibo Details</h3>
                    <div id="amiibo-details-content">
                        <div id="amiibo-details-image-container">
                            <img id="amiibo-details-image" src="" alt="Amiibo Image">
                        </div>
                        <div id="amiibo-details-info">
                            <p><strong>Name:</strong> <span id="detail-name"></span></p>
                            <p><strong>Amiibo Series:</strong> <span id="detail-amiibo-series"></span></p>
                            <p><strong>Game Series:</strong> <span id="detail-game-series"></span></p>
                            <p><strong>Release (NA):</strong> <span id="detail-release-na"></span></p>
                            <p><strong>Release (EU):</strong> <span id="detail-release-eu"></span></p>
                            <p><strong>Release (JP):</strong> <span id="detail-release-jp"></span></p>
                            <p><strong>Release (AU):</strong> <span id="detail-release-au"></span></p>
                        </div>
                    </div>
                </div>

                <div id="actions-container">
                    <h3>Actions</h3>
                    <input type="number" id="slot-input" min="1" max="8" value="1">
                    <button id="write-btn">Write to Slot</button>
                    <button id="emulate-btn">Emulate</button>
                    <p id="status"></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const connectBtn = document.getElementById('connect-btn');
        const amiiboBrowser = document.getElementById('amiibo-browser');
        const searchInput = document.getElementById('search-input');
        const gameSeriesFilter = document.getElementById('game-series-filter');
        const amiiboSeriesFilter = document.getElementById('amiibo-series-filter');
        const characterFilter = document.getElementById('character-filter');
        const sortBy = document.getElementById('sort-by');
        const clearFiltersSortBtn = document.getElementById('clear-filters-sort');
        const amiiboList = document.getElementById('amiibo-list');
        const amiiboDetails = document.getElementById('amiibo-details');
        const amiiboDetailsImage = document.getElementById('amiibo-details-image');
        const detailName = document.getElementById('detail-name');
        const detailAmiiboSeries = document.getElementById('detail-amiibo-series');
        const detailGameSeries = document.getElementById('detail-game-series');
        const detailReleaseNa = document.getElementById('detail-release-na');
        const detailReleaseEu = document.getElementById('detail-release-eu');
        const detailReleaseJp = document.getElementById('detail-release-jp');
        const detailReleaseAu = document.getElementById('detail-release-au');
        const actionsContainer = document.getElementById('actions-container');
        const slotInput = document.getElementById('slot-input');
        const writeBtn = document.getElementById('write-btn');
        const emulateBtn = document.getElementById('emulate-btn');
        const status = document.getElementById('status');
        const amiiboSlotsDiv = document.getElementById('amiibo-slots');
        const amiiboSlotsList = document.getElementById('amiibo-slots-list');

        // Modal elements
        const amiiboModal = document.getElementById('amiiboModal');
        const closeButton = document.querySelector('.close-button');

        const NRF_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
        const UART_RX_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
        const UART_TX_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

        const CMD_SET_ACTIVE_SLOT = 1003;
        const CMD_GET_SLOT_INFO = 1019;
        const CMD_GET_ALL_SLOT_NICKS = 1038;
        const CMD_GET_ENABLED_SLOTS = 1023;
        const CMD_SET_SLOT_TAG_TYPE = 1004;
        const CMD_SET_SLOT_DATA_DEFAULT = 1005;
        const CMD_MF1_SET_ANTICOLLISION = 4001;
        const CMD_MF0_NTAG_WRITE_EMU_PAGE_DATA = 4022;
        const CMD_SLOT_DATA_CONFIG_SAVE = 1009;
        const CMD_SET_SLOT_TAG_NICK = 1007;

        const TagType = { NTAG_215: 1101 };
        const TagFrequency = { HF: 2 }; // HF frequency value

        let ultra = null;
        let allAmiibos = [];
        let selectedAmiiboDetails = null; // Store the full details of the selected Amiibo
        let amiiboTemplate = null;

        function onDisconnected() {
            console.log('Device disconnected');
            connectBtn.textContent = 'Connect to Chameleon Ultra';
            connectBtn.disabled = false;
            amiiboBrowser.style.display = 'none';
            amiiboDetails.style.display = 'none'; // Hide details section
            actionsContainer.style.display = 'none'; // Hide actions section
            amiiboSlotsDiv.style.display = 'none';
            closeModal(); // Close modal on disconnect
            if (ultra && ultra.device) {
                ultra.device.removeEventListener('gattserverdisconnected', onDisconnected);
            }
            ultra = null;
            setStatus('Device disconnected.', 'error');
        }

        function setStatus(message, type = 'info') {
            status.textContent = message;
            status.className = ''; // Clear previous classes
            if (type === 'success') {
                status.classList.add('status-success');
            } else if (type === 'error') {
                status.classList.add('status-error');
            }
        }

        // Modal functions
        function openModal() {
            amiiboModal.style.display = 'flex'; // Use flex to center content
        }

        function closeModal() {
            amiiboModal.style.display = 'none';
            amiiboDetails.classList.remove('emulating'); // Remove emulating class when modal closes
            setStatus(''); // Clear status message
        }

        class ChameleonUltra {
            constructor() {
                this.device = null;
                this.rxCharacteristic = null;
                this.responseCallback = null;
                this.responseBuffer = new Uint8Array();
            }

            async connect() {
                this.device = await navigator.bluetooth.requestDevice({ filters: [{ services: [NRF_SERVICE_UUID] }] });
                this.device.addEventListener('gattserverdisconnected', onDisconnected);
                const server = await this.device.gatt.connect();
                const service = await server.getPrimaryService(NRF_SERVICE_UUID);
                this.rxCharacteristic = await service.getCharacteristic(UART_RX_UUID);
                const txCharacteristic = await service.getCharacteristic(UART_TX_UUID);
                await txCharacteristic.startNotifications();
                txCharacteristic.addEventListener('characteristicvaluechanged', this.handleNotifications.bind(this));
            }

            handleNotifications(event) {
                const value = new Uint8Array(event.target.value.buffer);
                const newBuffer = new Uint8Array(this.responseBuffer.length + value.length);
                newBuffer.set(this.responseBuffer);
                newBuffer.set(value, this.responseBuffer.length);
                this.responseBuffer = newBuffer;

                const sofIndex = this.responseBuffer.indexOf(0x11);
                if (sofIndex === -1 || this.responseBuffer[sofIndex + 1] !== 0xEF) return;
                if (this.responseBuffer.length < 10) return;

                const frameView = new DataView(this.responseBuffer.buffer);
                const dataLen = frameView.getUint16(sofIndex + 6, false);
                const frameLen = 10 + dataLen;

                if (this.responseBuffer.length >= sofIndex + frameLen) {
                    const frame = this.responseBuffer.slice(sofIndex, sofIndex + frameLen);
                    if (this.responseCallback) {
                        this.responseCallback(new DataView(frame.buffer));
                        this.responseCallback = null;
                    }
                    this.responseBuffer = this.responseBuffer.slice(sofIndex + frameLen);
                }
            }

            lrcCalc(data) {
                let ret = 0x00;
                for (const b of data) { ret = (ret + b) & 0xFF; }
                return (0x100 - ret) & 0xFF;
            }

            async sendCommand(cmd, data = new Uint8Array()) {
                return new Promise(async (resolve, reject) => {
                    if (!this.device || !this.device.gatt.connected) {
                        onDisconnected();
                        return reject(new Error('Device not connected'));
                    }

                    const header = new Uint8Array(6);
                    const view = new DataView(header.buffer);
                    view.setUint16(0, cmd, false);
                    view.setUint16(2, 0, false);
                    view.setUint16(4, data.length, false);

                    const frame = new Uint8Array(10 + data.length);
                    frame.set([0x11, 0xEF], 0);
                    frame.set(header, 2);
                    frame[8] = this.lrcCalc(Array.from(frame.slice(2, 8)));
                    frame.set(data, 9);
                    frame[frame.length - 1] = this.lrcCalc(Array.from(frame.slice(9, -1)));

                    this.responseCallback = (response) => {
                        const responseData = new DataView(response.buffer, 9, response.byteLength - 10);
                        resolve(responseData);
                    };

                    setTimeout(() => reject(new Error('Command timed out')), 5000);
                    await this.rxCharacteristic.writeValue(frame);
                });
            }

            async getSlotNames() {
                const response = await this.sendCommand(CMD_GET_ALL_SLOT_NICKS);
                const slots = [];
                let offset = 0;
                const textDecoder = new TextDecoder();
                for (let i = 0; i < 8; i++) {
                    const hfLen = response.getUint8(offset++);
                    const hfName = hfLen > 0 ? textDecoder.decode(new Uint8Array(response.buffer, response.byteOffset + offset, hfLen)) : '';
                    offset += hfLen;
                    const lfLen = response.getUint8(offset++);
                    const lfName = lfLen > 0 ? textDecoder.decode(new Uint8Array(response.buffer, response.byteOffset + offset, lfLen)) : '';
                    offset += lfLen;
                    slots.push({ hfName, lfName });
                }
                return slots;
            }

            async _writeNtag215(slot, data, uid) {
                const setTypeData = new Uint8Array(3);
                const setTypeView = new DataView(setTypeData.buffer);
                setTypeView.setUint8(0, slot);
                setTypeView.setUint16(1, TagType.NTAG_215, false);
                await this.sendCommand(CMD_SET_SLOT_TAG_TYPE, setTypeData);

                const setDefaultData = new Uint8Array(3);
                const setDefaultView = new DataView(setDefaultData.buffer);
                setDefaultView.setUint8(0, slot);
                setDefaultView.setUint16(1, TagType.NTAG_215, false);
                await this.sendCommand(CMD_SET_SLOT_DATA_DEFAULT, setDefaultData);

                const atqa = new Uint8Array([0x00, 0x44]);
                const sak = 0x00;
                const ats = new Uint8Array([]);
                const antiCollData = new Uint8Array(1 + uid.length + atqa.length + 1 + ats.length);
                let offset = 0;
                antiCollData[offset++] = uid.length;
                antiCollData.set(uid, offset); offset += uid.length;
                antiCollData.set(atqa, offset); offset += atqa.length;
                antiCollData[offset++] = sak;
                antiCollData[offset++] = ats.length;
                if (ats.length > 0) antiCollData.set(ats, offset);
                await this.sendCommand(CMD_MF1_SET_ANTICOLLISION, antiCollData);

                const pageSize = 4;
                for (let i = 0; i < data.length; i += pageSize) {
                    const page = i / pageSize;
                    let chunk = data.slice(i, i + pageSize);
                    if (chunk.length < pageSize) {
                        const paddedChunk = new Uint8Array(pageSize);
                        paddedChunk.set(chunk);
                        chunk = paddedChunk;
                    }
                    const writeData = new Uint8Array(2 + chunk.length);
                    const writeView = new DataView(writeData.buffer);
                    writeView.setUint8(0, page);
                    writeView.setUint8(1, 1);
                    writeData.set(chunk, 2);
                    await this.sendCommand(CMD_MF0_NTAG_WRITE_EMU_PAGE_DATA, writeData);
                }
            }

            async writeNtag215ToSlot(slot, data, uid, name) {
                await this._writeNtag215(slot, data, uid);
                const textEncoder = new TextEncoder();
                let nameBytes = textEncoder.encode(name);
                if (nameBytes.length > 255) {
                    nameBytes = nameBytes.slice(0, 255);
                }
                const setNameData = new Uint8Array(2 + nameBytes.length);
                setNameData[0] = slot;
                setNameData[1] = TagFrequency.HF; // HF frequency
                setNameData.set(nameBytes, 2);
                await this.sendCommand(CMD_SET_SLOT_TAG_NICK, setNameData);
                await this.sendCommand(CMD_SLOT_DATA_CONFIG_SAVE);
            }

            async emulateNtag215(slot, data, uid) {
                const activateSlotData = new Uint8Array([slot]);
                await this.sendCommand(CMD_SET_ACTIVE_SLOT, activateSlotData);
                await this._writeNtag215(slot, data, uid);
            }
        }

        async function generateAmiiboData(amiiboDetails) {
            if (!amiiboTemplate) {
                const response = await fetch('NTAG215_blank_valid_signature.bin');
                const buffer = await response.arrayBuffer();
                amiiboTemplate = new Uint8Array(buffer);
            }

            const data = new Uint8Array(amiiboTemplate);

            // Amiibo ID is amiiboDetails.head + amiiboDetails.tail
            const amiiboId = amiiboDetails.head + amiiboDetails.tail;
            const idBytes = [];
            for (let i = 0; i < amiiboId.length; i += 2) {
                idBytes.push(parseInt(amiiboId.substring(i, i + 2), 16));
            }
            data.set(idBytes, 84); // Offset 84 for Amiibo ID

            const uid = new Uint8Array(7);
            uid[0] = 0x04; // NTAG215 UID starts with 0x04
            for (let i = 1; i < 7; i++) {
                uid[i] = Math.floor(Math.random() * 256);
            }
            // Calculate BCC0 and BCC1
            const bcc0 = uid[0] ^ uid[1] ^ uid[2] ^ uid[3];
            const bcc1 = uid[4] ^ uid[5] ^ uid[6] ^ bcc0;

            // Set UID and BCC bytes in the data
            data.set(uid.slice(0, 4), 0); // UID bytes 0-3 at offset 0
            data.set(uid.slice(4, 7), 4); // UID bytes 4-6 at offset 4
            data[7] = bcc0; // BCC0 at offset 7
            data[8] = bcc1; // BCC1 at offset 8

            return { pageData: data, uid: uid };
        }

        async function loadAmiiboList() {
            setStatus('Loading Amiibo list...');
            try {
                const response = await fetch('https://www.amiiboapi.com/api/amiibo/');
                const data = await response.json();
                allAmiibos = data.amiibo.map(amiibo => ({ id: amiibo.head + amiibo.tail, ...amiibo }));
                populateFilterDropdowns(); // Populate dropdowns after loading data
                applyFiltersAndSort(); // Initial render with all filters/sort applied
                setStatus('Amiibo list loaded.', 'success');
            } catch (error) {
                console.error('Error loading Amiibo list:', error);
                setStatus('Failed to load Amiibo list.', 'error');
            }
        }

        function populateFilterDropdowns() {
            // Populate filter dropdowns
            populateFilterDropdown(gameSeriesFilter, [...new Set(allAmiibos.map(a => a.gameSeries).filter(Boolean))].sort());
            populateFilterDropdown(amiiboSeriesFilter, [...new Set(allAmiibos.map(a => a.amiiboSeries).filter(Boolean))].sort());
            populateFilterDropdown(characterFilter, [...new Set(allAmiibos.map(a => a.character).filter(Boolean))].sort());
        }

        function populateFilterDropdown(selectElement, options) {
            // Keep the first "All" option
            selectElement.innerHTML = selectElement.options[0].outerHTML;
            options.forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option;
                selectElement.appendChild(opt);
            });
        }

        function applyFiltersAndSort() {
            let filteredAmiibos = [...allAmiibos]; // Start with a copy of all amiibos

            // 1. Apply Search Filter
            const searchTerm = searchInput.value.toLowerCase();
            if (searchTerm) {
                filteredAmiibos = filteredAmiibos.filter(amiibo =>
                    amiibo.name.toLowerCase().includes(searchTerm)
                );
            }

            // 2. Apply Game Series Filter
            const selectedGameSeries = gameSeriesFilter.value;
            if (selectedGameSeries) {
                filteredAmiibos = filteredAmiibos.filter(amiibo =>
                    amiibo.gameSeries === selectedGameSeries
                );
            }

            // 3. Apply Amiibo Series Filter
            const selectedAmiiboSeries = amiiboSeriesFilter.value;
            if (selectedAmiiboSeries) {
                filteredAmiibos = filteredAmiibos.filter(amiibo =>
                    amiibo.amiiboSeries === selectedAmiiboSeries
                );
            }

            // 4. Apply Character Filter
            const selectedCharacter = characterFilter.value;
            if (selectedCharacter) {
                filteredAmiibos = filteredAmiibos.filter(amiibo =>
                    amiibo.character === selectedCharacter
                );
            }

            // 5. Apply Sorting
            const sortOption = sortBy.value;
            filteredAmiibos.sort((a, b) => {
                if (sortOption === 'name-asc') {
                    return a.name.localeCompare(b.name);
                } else if (sortOption === 'name-desc') {
                    return b.name.localeCompare(a.name);
                } else if (sortOption === 'release-na-asc') {
                    // Handle potential null/undefined release dates
                    const dateA = a.release.na ? new Date(a.release.na) : new Date(0); // Use epoch for null dates
                    const dateB = b.release.na ? new Date(b.release.na) : new Date(0);
                    return dateA - dateB;
                } else if (sortOption === 'release-na-desc') {
                    const dateA = a.release.na ? new Date(a.release.na) : new Date(0);
                    const dateB = b.release.na ? new Date(b.release.na) : new Date(0);
                    return dateB - dateA;
                }
                return 0; // No sort or unknown option
            });

            renderAmiiboList(filteredAmiibos);
        }

        async function refreshAmiiboSlots() {
            if (!ultra || !ultra.device || !ultra.device.gatt.connected) {
                amiiboSlotsDiv.style.display = 'none';
                return;
            }
            try {
                const responseSlotInfo = await ultra.sendCommand(CMD_GET_SLOT_INFO);
                const slotNames = await ultra.getSlotNames(); // Use the correct function to get names

                amiiboSlotsList.innerHTML = '';
                let hasAmiiboSlots = false;

                for (let i = 0; i < 8; i++) {
                    const hfTagType = responseSlotInfo.getUint16(i * 4, false);
                    
                    if (hfTagType === TagType.NTAG_215) {
                        hasAmiiboSlots = true;
                        const hfName = slotNames[i].hfName || 'Unnamed Amiibo';

                        const slotItem = document.createElement('div');
                        slotItem.className = 'slot-item';
                        slotItem.textContent = `Slot ${i + 1}: ${hfName}`;
                        amiiboSlotsList.appendChild(slotItem);
                    }
                }
                amiiboSlotsDiv.style.display = hasAmiiboSlots ? 'block' : 'none';
            } catch (error) {
                console.error('Error refreshing Amiibo slots:', error);
                amiiboSlotsDiv.style.display = 'none';
            }
        }

        function renderAmiiboList(amiibos) {
            amiiboList.innerHTML = '';
            for (const amiibo of amiibos) {
                const card = document.createElement('div');
                card.className = 'amiibo-card';
                card.dataset.id = amiibo.id;
                card.innerHTML = `<img src="${amiibo.image}" alt="${amiibo.name}"><p>${amiibo.name}</p>`;
                card.addEventListener('click', () => {
                    const currentlySelected = document.querySelector('.amiibo-card.selected');
                    if (currentlySelected) currentlySelected.classList.remove('selected');
                    card.classList.add('selected');
                    selectedAmiiboDetails = amiibo; // Store the full amiibo object
                    displayAmiiboDetails(amiibo);
                    amiiboDetails.classList.remove('emulating'); // Remove emulating class from previous selection
                    amiiboDetails.style.display = 'block'; // Show details when selected
                    actionsContainer.style.display = 'block';
                    openModal(); // Open modal when amiibo is selected
                });
                amiiboList.appendChild(card);
            }
        }

        function displayAmiiboDetails(amiibo) {
            amiiboDetailsImage.src = amiibo.image;
            detailName.textContent = amiibo.name;
            detailAmiiboSeries.textContent = amiibo.amiiboSeries;
            detailGameSeries.textContent = amiibo.gameSeries;
            detailReleaseNa.textContent = amiibo.release.na || 'N/A';
            detailReleaseEu.textContent = amiibo.release.eu || 'N/A';
            detailReleaseJp.textContent = amiibo.release.jp || 'N/A';
            detailReleaseAu.textContent = amiibo.release.au || 'N/A';
        }

        // Filter and Sort Event Listeners
        gameSeriesFilter.addEventListener('change', applyFiltersAndSort);
        amiiboSeriesFilter.addEventListener('change', applyFiltersAndSort);
        characterFilter.addEventListener('change', applyFiltersAndSort);
        sortBy.addEventListener('change', applyFiltersAndSort);
        searchInput.addEventListener('input', applyFiltersAndSort); // Already exists, but ensure it calls new function

        clearFiltersSortBtn.addEventListener('click', () => {
            searchInput.value = '';
            gameSeriesFilter.value = '';
            amiiboSeriesFilter.value = '';
            characterFilter.value = '';
            sortBy.value = 'name-asc';
            applyFiltersAndSort();
        });

        connectBtn.addEventListener('click', async () => {
            try {
                setStatus('Connecting...');
                ultra = new ChameleonUltra();
                await ultra.connect();
                connectBtn.textContent = 'Connected';
                connectBtn.disabled = true;
                amiiboBrowser.style.display = 'block';
                await loadAmiiboList(); // Await loading list before refreshing slots
                refreshAmiiboSlots(); // Refresh slots on connect
                setStatus('Connected.', 'success');
            } catch (error) {
                console.error('Error:', error);
                setStatus('Connection Failed.', 'error');
            }
        });

        writeBtn.addEventListener('click', async () => {
            if (!selectedAmiiboDetails) {
                setStatus('Please select an Amiibo.', 'error');
                return;
            }
            const slot = parseInt(slotInput.value, 10) - 1;
            if (slot < 0 || slot > 7) {
                setStatus('Invalid slot number.', 'error');
                return;
            }
            try {
                setStatus('Generating and writing...');
                const { pageData, uid } = await generateAmiiboData(selectedAmiiboDetails);
                await ultra.writeNtag215ToSlot(slot, pageData, uid, selectedAmiiboDetails.name);
                setStatus('Write successful!', 'success');
                refreshAmiiboSlots(); // Refresh slots after write
                amiiboDetails.classList.remove('emulating'); // Remove emulating class after write
                closeModal(); // Close modal after successful write
            } catch (error) {
                console.error('Write Error:', error);
                setStatus('Write failed.', 'error');
            }
        });

        emulateBtn.addEventListener('click', async () => {
            if (!selectedAmiiboDetails) {
                setStatus('Please select an Amiibo.', 'error');
                return;
            }
            const slot = parseInt(slotInput.value, 10) - 1;
            if (slot < 0 || slot > 7) {
                setStatus('Invalid slot number.', 'error');
                return;
            }
            try {
                setStatus('Generating and emulating...');
                const { pageData, uid } = await generateAmiiboData(selectedAmiiboDetails);
                await ultra.emulateNtag215(slot, pageData, uid);
                setStatus('Emulation started!', 'success');
                refreshAmiiboSlots(); // Refresh slots after emulate
                amiiboDetails.classList.add('emulating'); // Add emulating class to current selection
                closeModal(); // Close modal after successful emulate
            } catch (error) {
                console.error('Emulation Error:', error);
                setStatus('Emulation failed.', 'error');
            }
        });

        // Event listener for closing the modal
        closeButton.addEventListener('click', closeModal);
        window.addEventListener('click', (event) => {
            if (event.target == amiiboModal) {
                closeModal();
            }
        });

    </script>
</body>
</html>