<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chameleon Ultra Amiibo Emulator</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f7f6;
            color: #333;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        input[type="text"], input[type="number"], select {
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        #connect-btn {
            margin-bottom: 20px;
        }
        .container {
            max-width: 800px;
            width: 100%;
        }

        #status-section {
            margin-bottom: 20px;
        }

        #upload-status {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            color: #333;
        }

        #upload-status.success {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        #upload-status.error {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        .upload-input {
            display: none;
        }
        /* Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto; /* Center the modal */
            padding: 20px;
            border: 1px solid #888;
            border-radius: 10px;
            width: 80%; /* Could be more responsive */
            max-width: 700px;
            box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
            animation-name: animatetop;
            animation-duration: 0.4s;
            display: flex; /* Use flex for inner content */
            flex-direction: column;
            gap: 20px;
        }
        /* Add Animation */
        @-webkit-keyframes animatetop {
            from {top: -300px; opacity: 0}
            to {top: 0; opacity: 1}
        }
        @keyframes animatetop {
            from {top: -300px; opacity: 0}
            to {top: 0; opacity: 1}
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        #amiibo-info-and-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 5px; /* Reduced gap */
            width: 100%;
            /* max-width: 1200px; */ /* Removed as it's now inside modal */
            margin-bottom: 0; /* Removed as it's now inside modal */
        }
        #amiibo-details {
            flex: 2 1 400px; /* Allows it to grow and shrink, min-width 400px */
            display: block; /* Always block inside modal */
            background-color: #fff;
            padding: 0; /* Padding handled by modal-content */
            border-radius: 8px;
            box-shadow: none; /* Shadow handled by modal-content */
            text-align: left;
        }
        #amiibo-details h3 {
            text-align: center;
            margin-top: 0;
        }
        #amiibo-details-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        #amiibo-details-image-container {
            flex: 1 1 150px;
            text-align: center;
        }
        #amiibo-details-image {
            max-width: 150px;
            height: auto;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        #amiibo-details-info {
            flex: 2 1 300px;
        }
        #amiibo-details-info p {
            margin: 5px 0;
            font-size: 1em;
        }
        #actions-container {
            flex: 1 1 300px; /* Allows it to grow and shrink, min-width 300px */
            display: block; /* Always block inside modal */
            background-color: #fff;
            padding: 0; /* Padding handled by modal-content */
            border-radius: 8px;
            box-shadow: none; /* Shadow handled by modal-content */
            text-align: center;
        }
        #status {
            margin-top: 15px;
            font-weight: bold;
            color: #555;
        }
        .status-success {
            color: #28a745;
        }
        .status-error {
            color: #dc3545;
        }
        #amiibo-slots {
            width: 100%;
            max-width: 800px;
            display: none;
        }
        .well {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 1px 1px rgba(0,0,0,.05);
        }

        .slot {
            border-left: 4px solid #007bff;
            position: relative;
        }

        .slot-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
        }

        .slot-summary {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .slot-summary img {
            border: 1px solid #ddd;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .slot-summary img:hover {
            transform: scale(1.1);
            transition: transform 0.2s ease;
        }

        .slot-links {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .slot-links li {
            margin: 0;
        }

        .slot-links a {
            color: #007bff;
            text-decoration: none;
            font-size: 14px;
            padding: 4px 8px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .slot-links a:hover {
            background-color: #f8f9fa;
            text-decoration: underline;
        }

        .slot-empty {
            border-left-color: #ccc;
        }

        .slot-empty .slot-title {
            color: #999;
        }

        .slot-selected {
            border-left-color: #28a745;
        }

        .slot-selected .slot-title {
            color: #28a745;
        }
        .amiibo-details.emulating {
            border: 2px solid #28a745; /* Green border for emulating */
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.5); /* Green glow */
        }

        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                padding: 10px;
            }

            body {
                padding: 10px;
            }

            .slot-links {
                flex-direction: column;
                gap: 8px;
                align-items: flex-start;
            }

            .slot-links a {
                display: inline-block;
                padding: 8px 12px;
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                width: 100%;
                text-align: center;
                box-sizing: border-box;
            }

            .well {
                padding: 12px;
                margin-bottom: 12px;
            }
        }

        /* Recent Amiibo Cards */
        .recent-amiibo-card {
            flex-shrink: 0;
            width: 80px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
            text-align: center;
        }

        .recent-amiibo-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            border-color: #007bff;
        }

        .recent-amiibo-card.selected {
            border-color: #007bff;
            background-color: #e7f3ff;
        }

        .recent-amiibo-card img {
            width: 60px;
            height: 60px;
            border-radius: 4px;
            margin-bottom: 4px;
        }

        .recent-amiibo-card .name {
            font-size: 11px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Generate Modal Tabs */
        .generate-tabs {
            display: flex;
            border-bottom: 2px solid #f0f0f0;
            margin-bottom: 20px;
        }

        .tab-btn {
            background: none;
            border: none;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
            flex: 1;
        }

        .tab-btn:hover {
            color: #007bff;
            background-color: #f8f9fa;
        }

        .tab-btn.active {
            color: #007bff;
            border-bottom-color: #007bff;
            background-color: #f8f9fa;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .recent-amiibo-card, .favorite-amiibo-card {
            position: relative;
        }
    </style>

</head>
<body>
    <h1>Chameleon Ultra Amiibo Emulator</h1>

    <!-- Battery Status -->
    <div id="battery-status" style="position: fixed; top: 20px; right: 20px; z-index: 1001; background: rgba(255,255,255,0.9); padding: 8px 12px; border-radius: 20px; border: 1px solid #ddd; font-size: 0.9em; display: none; backdrop-filter: blur(5px);">
        <span id="battery-icon">🔋</span> <span id="battery-text">---%</span>
    </div>

    <!-- Notification Container -->
    <div id="notification-container" style="position: fixed; top: 60px; right: 20px; z-index: 1000; max-width: 400px;"></div>

    <button id="connect-btn">Connect to Chameleon Ultra</button>
    <button id="refresh-slots-btn" style="margin-left: 10px; display: none;">Refresh Slots</button>

    <div style="margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;">
        <h3 style="margin-top: 0;">Retail Key Status</h3>
        <div id="key-status" style="margin-bottom: 10px; padding: 8px; border-radius: 4px;">No retail keys loaded</div>
        <input type="file" id="key-file-input" accept=".bin" style="display: none;">
        <button id="load-keys-btn" onclick="document.getElementById('key-file-input').click();">Upload retail keys</button>
        <button id="clear-keys-btn" style="margin-left: 10px; background-color: #6c757d; display: none;">Clear Keys</button>
        <p style="margin: 5px 0 0 0; font-size: 0.9em; color: #666;">Upload key_retail.bin to generate encrypted amiibo files</p>
    </div>

    <div class="container">
        <div id="status-section" style="display: none;">
            <div id="upload-status" style="font-weight: bold; margin-bottom: 20px; padding: 10px; border-radius: 4px;"></div>
        </div>

        <div id="amiibo-slots">
            <h2>Amiibo Tags</h2>
            <div id="amiibo-slots-list"></div>
        </div>
    </div>

    <!-- The Modal -->
    <div id="amiiboModal" class="modal">
        <!-- Modal content -->
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <div id="amiibo-info-and-actions">
                <div id="amiibo-details">
                    <h3>Selected Amiibo Details</h3>
                    <div id="amiibo-details-content">
                        <div id="amiibo-details-image-container">
                            <img id="amiibo-details-image" src="" alt="Amiibo Image">
                        </div>
                        <div id="amiibo-details-info">
                            <p><strong>Name:</strong> <span id="detail-name"></span></p>
                            <p><strong>Amiibo Series:</strong> <span id="detail-amiibo-series"></span></p>
                            <p><strong>Game Series:</strong> <span id="detail-game-series"></span></p>
                            <p><strong>Release (NA):</strong> <span id="detail-release-na"></span></p>
                            <p><strong>Release (EU):</strong> <span id="detail-release-eu"></span></p>
                            <p><strong>Release (JP):</strong> <span id="detail-release-jp"></span></p>
                            <p><strong>Release (AU):</strong> <span id="detail-release-au"></span></p>
                        </div>
                    </div>
                </div>

                <div id="actions-container">
                    <h3>Actions</h3>
                    <p id="selected-slot-details">Select a slot to see details</p> <!-- New: Element to display selected slot details -->
                    <select id="slot-select">
                        <option value="0">Slot 1</option>
                        <option value="1">Slot 2</option>
                        <option value="2">Slot 3</option>
                        <option value="3">Slot 4</option>
                        <option value="4">Slot 5</option>
                        <option value="5">Slot 6</option>
                        <option value="6">Slot 7</option>
                        <option value="7">Slot 8</option>
                    </select>
                    <div style="margin: 10px 0;">
                        <label style="display: flex; align-items: center; justify-content: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="random-uid-toggle" style="cursor: pointer;">
                            <span>Use Random UID</span>
                        </label>
                    </div>
                    <button id="write-btn">Write to Slot</button>
                    <button id="emulate-btn">Emulate</button>
                    <button id="download-amiibo-btn">Download .bin</button>
                    <p id="status"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Slot Details Modal -->
    <div id="slotModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="slot-close-button">&times;</span>
            <div id="slot-info-and-actions">
                <div id="slot-details">
                    <h3>Slot Details</h3>
                    <div id="slot-details-content">
                        <div id="slot-details-image-container">
                            <img id="slot-details-image" src="" alt="Amiibo Image">
                        </div>
                        <div id="slot-details-info">
                            <p><strong>Slot:</strong> <span id="slot-detail-slot"></span></p>
                            <p><strong>Name:</strong> <span id="slot-detail-name"></span></p>
                            <p><strong>Amiibo Series:</strong> <span id="slot-detail-amiibo-series"></span></p>
                            <p><strong>Game Series:</strong> <span id="slot-detail-game-series"></span></p>
                            <p><strong>Release (NA):</strong> <span id="slot-detail-release-na"></span></p>
                            <p><strong>Release (EU):</strong> <span id="slot-detail-release-eu"></span></p>
                            <p><strong>Release (JP):</strong> <span id="slot-detail-release-jp"></span></p>
                            <p><strong>Release (AU):</strong> <span id="slot-detail-release-au"></span></p>
                        </div>
                    </div>
                </div>

                <div id="slot-actions-container">
                    <h3>Actions</h3>
                    <div style="margin: 10px 0;">
                        <label style="display: flex; align-items: center; justify-content: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="slot-random-uid-toggle" style="cursor: pointer;">
                            <span>Use Random UID</span>
                        </label>
                    </div>
                    <button id="slot-write-btn">Write to Slot</button>
                    <button id="slot-emulate-btn" style="display: none;">Emulate</button>
                    <p id="slot-status"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Clear Slot Confirmation Modal -->
    <div id="clearSlotModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <span class="close-button" id="clear-close-button">&times;</span>
            <h3>Clear Slot</h3>
            <p>Are you sure you want to clear <strong id="clear-slot-name">Slot X</strong>?</p>
            <p style="color: #666; font-size: 0.9em;">This will permanently delete the Amiibo data from the device.</p>
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                <button id="clear-cancel-btn" style="background-color: #6c757d;">Cancel</button>
                <button id="clear-confirm-btn" style="background-color: #dc3545;">Clear Slot</button>
            </div>
        </div>
    </div>

    <!-- Upload Modal -->
    <div id="uploadModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <span class="close-button" id="upload-close-button">&times;</span>
            <h3>Upload Amiibo to <span id="upload-slot-name">Slot X</span></h3>

            <div style="margin-bottom: 15px;">
                <input type="file" id="upload-file-input" accept=".bin,.nfc" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; margin-right: 10px;">
            </div>

            <div id="upload-randomize-section" style="margin-bottom: 15px; display: none;">
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                    <input type="checkbox" id="upload-randomize-uid" style="cursor: pointer;">
                    <span>Randomize UID</span>
                </label>
            </div>

            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="upload-cancel-btn" style="background-color: #6c757d;">Cancel</button>
                <button id="upload-confirm-btn">Write</button>
                <button id="upload-emulate-btn" style="background-color: #28a745; display: none;">Upload & Emulate</button>
            </div>

            <div id="upload-modal-status" style="margin-top: 15px; padding: 10px; border-radius: 4px; display: none;"></div>
        </div>
    </div>

    <!-- Generate Amiibo Modal -->
    <div id="generateModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="generate-close-button">&times;</span>
            <h3>Generate Amiibo for <span id="generate-slot-name">Slot X</span></h3>

            <!-- Tab Navigation -->
            <div class="generate-tabs" style="margin-bottom: 20px;">
                <button class="tab-btn active" data-tab="recent">⏱️ Recent</button>
                <button class="tab-btn" data-tab="favorites">⭐ Favorites</button>
                <button class="tab-btn" data-tab="search">🔍 Search</button>
            </div>

            <!-- Recent Tab Content -->
            <div id="recent-tab" class="tab-content active">
                <div id="recent-amiibos-container" style="display: flex; gap: 10px; overflow-x: auto; padding: 4px 0 10px 0; min-height: 120px; align-items: flex-start;">
                    <div style="text-align: center; color: #999; width: 100%; padding: 40px 0;">No recent amiibos</div>
                </div>
            </div>

            <!-- Favorites Tab Content -->
            <div id="favorites-tab" class="tab-content">
                <div id="favorites-amiibos-container" style="display: flex; gap: 10px; overflow-x: auto; padding: 4px 0 10px 0; min-height: 120px; align-items: flex-start;">
                    <div style="text-align: center; color: #999; width: 100%; padding: 40px 0;">No favorite amiibos</div>
                </div>
            </div>

            <!-- Search Tab Content -->
            <div id="search-tab" class="tab-content">
                <!-- Search Section -->
            <div style="margin-bottom: 20px;">
                <input type="text" id="amiibo-search" placeholder="Search for amiibo by name..."
                       style="width: 100%; margin-bottom: 10px; box-sizing: border-box;">

                <!-- Filters and Sort -->
                <div style="display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">
                    <div style="flex: 1; min-width: 150px;">
                        <label style="font-size: 0.9em; color: #666;">Game Series:</label>
                        <select id="game-series-filter" style="width: 100%; padding: 5px; box-sizing: border-box;">
                            <option value="">All Game Series</option>
                        </select>
                    </div>
                    <div style="flex: 1; min-width: 120px;">
                        <label style="font-size: 0.9em; color: #666;">Sort by:</label>
                        <select id="sort-option" style="width: 100%; padding: 5px; box-sizing: border-box;">
                            <option value="newest">Newest First</option>
                            <option value="oldest">Oldest First</option>
                        </select>
                    </div>
                    <div style="display: flex; align-items: end;">
                        <button id="clear-filters-btn" style="padding: 5px 10px; background-color: #6c757d;">Clear</button>
                    </div>
                </div>

                <div id="results-info" style="font-size: 0.9em; color: #666; margin-bottom: 5px; display: none;"></div>
                <div id="amiibo-search-results" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; display: none;">
                    <!-- Search results will be populated here -->
                </div>
            </div>

            <!-- Selected Amiibo Section -->
            <div id="selected-amiibo-section" style="display: none;">
                <h4>Selected Amiibo</h4>
                <div style="display: flex; align-items: center; gap: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 15px;">
                    <img id="selected-amiibo-image" src="" alt="" style="width: 60px; height: 60px; object-fit: cover;">
                    <div style="flex: 1;">
                        <div style="font-weight: bold;" id="selected-amiibo-name"></div>
                        <div style="color: #666; font-size: 0.9em;" id="selected-amiibo-series"></div>
                        <div style="color: #888; font-size: 0.8em;" id="selected-amiibo-id"></div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="favorite-checkbox" style="cursor: pointer;">
                        <label for="favorite-checkbox" style="cursor: pointer; font-size: 14px;">⭐ Favorite</label>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="generate-cancel-btn" style="background-color: #6c757d;">Cancel</button>
                    <button id="generate-write-btn">Write</button>
                    <button id="generate-emulate-btn" style="background-color: #28a745; display: none;">Emulate</button>
                </div>
            </div>
            <!-- End Search Tab Content -->
            </div>

        </div>
    </div>

    <!-- Download Modal -->
    <div id="downloadModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <span class="close-button" id="download-close-button">&times;</span>
            <h3>Download Amiibo</h3>
            <p>Download <strong id="download-slot-name">Slot X</strong> as a .bin file?</p>
            <p style="color: #666; font-size: 0.9em;">This feature is not yet implemented. The download would export the tag data as a .bin file compatible with other Amiibo tools.</p>
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                <button id="download-cancel-btn" style="background-color: #6c757d;">Cancel</button>
                <button id="download-confirm-btn" disabled style="background-color: #ccc;">Download (Coming Soon)</button>
            </div>
        </div>
    </div>

    <!-- Upload Progress Modal -->
    <div id="uploadProgressModal" class="modal">
        <div class="modal-content" style="max-width: 500px; text-align: center;">
            <h3 id="upload-progress-title">Processing...</h3>
            <div id="upload-progress-message" style="margin: 20px 0; font-size: 1.1em;">
                Preparing upload...
            </div>
            <div style="width: 100%; background-color: #f0f0f0; border-radius: 20px; margin: 20px 0;">
                <div id="upload-progress-bar" style="width: 0%; height: 30px; background: linear-gradient(90deg, #007bff, #28a745); border-radius: 20px; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                    <span id="upload-progress-percent">0%</span>
                </div>
            </div>
            <div id="upload-details" style="color: #666; font-size: 0.9em; margin-top: 10px;">
                <!-- Details about current step will appear here -->
            </div>
        </div>
    </div>

    <script src="maboii.js"></script>
    <script>
        const connectBtn = document.getElementById('connect-btn');
        const refreshSlotsBtn = document.getElementById('refresh-slots-btn');
        const batteryStatus = document.getElementById('battery-status');
        const batteryIcon = document.getElementById('battery-icon');
        const batteryText = document.getElementById('battery-text');
        const amiiboDetails = document.getElementById('amiibo-details');
        const amiiboDetailsImage = document.getElementById('amiibo-details-image');
        const detailName = document.getElementById('detail-name');
        const detailAmiiboSeries = document.getElementById('detail-amiibo-series');
        const detailGameSeries = document.getElementById('detail-game-series');
        const detailReleaseNa = document.getElementById('detail-release-na');
        const detailReleaseEu = document.getElementById('detail-release-eu');
        const detailReleaseJp = document.getElementById('detail-release-jp');
        const detailReleaseAu = document.getElementById('detail-release-au');
        const actionsContainer = document.getElementById('actions-container');
        const slotSelect = document.getElementById('slot-select'); // New: Reference to the select element
        const writeBtn = document.getElementById('write-btn');
        const emulateBtn = document.getElementById('emulate-btn');
        const randomUidToggle = document.getElementById('random-uid-toggle');
        const status = document.getElementById('status');
        const amiiboSlotsDiv = document.getElementById('amiibo-slots');
        const amiiboSlotsList = document.getElementById('amiibo-slots-list');
        const selectedSlotDetailsElement = document.getElementById('selected-slot-details'); // New: Reference to the selected slot details element

        // Status elements
        const statusSection = document.getElementById('status-section');
        const uploadStatus = document.getElementById('upload-status');

        // Clear modal elements
        const clearSlotModal = document.getElementById('clearSlotModal');
        const clearCloseButton = document.getElementById('clear-close-button');
        const clearSlotName = document.getElementById('clear-slot-name');
        const clearCancelBtn = document.getElementById('clear-cancel-btn');
        const clearConfirmBtn = document.getElementById('clear-confirm-btn');

        // Download modal elements
        const downloadModal = document.getElementById('downloadModal');

        // Upload Progress modal elements
        const uploadProgressModal = document.getElementById('uploadProgressModal');
        const uploadProgressTitle = document.getElementById('upload-progress-title');
        const uploadProgressMessage = document.getElementById('upload-progress-message');
        const uploadProgressBar = document.getElementById('upload-progress-bar');
        const uploadProgressPercent = document.getElementById('upload-progress-percent');
        const uploadDetails = document.getElementById('upload-details');
        const downloadCloseButton = document.getElementById('download-close-button');
        const downloadSlotName = document.getElementById('download-slot-name');
        const downloadCancelBtn = document.getElementById('download-cancel-btn');
        const downloadConfirmBtn = document.getElementById('download-confirm-btn');

        // Modal elements
        const amiiboModal = document.getElementById('amiiboModal');
        const closeButton = document.querySelector('.close-button');

        // Slot Modal elements
        const slotModal = document.getElementById('slotModal');
        const slotCloseButton = document.getElementById('slot-close-button');
        const slotDetailsImage = document.getElementById('slot-details-image');
        const slotDetailSlot = document.getElementById('slot-detail-slot');
        const slotDetailName = document.getElementById('slot-detail-name');
        const slotDetailAmiiboSeries = document.getElementById('slot-detail-amiibo-series');
        const slotDetailGameSeries = document.getElementById('slot-detail-game-series');
        const slotDetailReleaseNa = document.getElementById('slot-detail-release-na');
        const slotDetailReleaseEu = document.getElementById('slot-detail-release-eu');
        const slotDetailReleaseJp = document.getElementById('slot-detail-release-jp');
        const slotDetailReleaseAu = document.getElementById('slot-detail-release-au');

        // Generate modal elements
        const generateModal = document.getElementById('generateModal');
        const generateCloseButton = document.getElementById('generate-close-button');
        const amiiboSearch = document.getElementById('amiibo-search');
        const amiiboSearchResults = document.getElementById('amiibo-search-results');
        const resultsInfo = document.getElementById('results-info');
        const generateCancelBtn = document.getElementById('generate-cancel-btn');
        const generateWriteBtn = document.getElementById('generate-write-btn');
        const generateEmulateBtn = document.getElementById('generate-emulate-btn');
        const gameSeriesFilter = document.getElementById('game-series-filter');
        const sortOption = document.getElementById('sort-option');
        const clearFiltersBtn = document.getElementById('clear-filters-btn');

        // Key management elements
        const keyStatus = document.getElementById('key-status');
        const keyFileInput = document.getElementById('key-file-input');
        const loadKeysBtn = document.getElementById('load-keys-btn');
        const clearKeysBtn = document.getElementById('clear-keys-btn');

        // Upload modal elements
        const uploadModal = document.getElementById('uploadModal');
        const uploadCloseButton = document.getElementById('upload-close-button');
        const uploadFileInput = document.getElementById('upload-file-input');
        const uploadRandomizeUid = document.getElementById('upload-randomize-uid');
        const uploadRandomizeSection = document.getElementById('upload-randomize-section');
        const uploadCancelBtn = document.getElementById('upload-cancel-btn');
        const uploadConfirmBtn = document.getElementById('upload-confirm-btn');
        const uploadEmulateBtn = document.getElementById('upload-emulate-btn');
        const uploadSlotName = document.getElementById('upload-slot-name');
        const uploadModalStatus = document.getElementById('upload-modal-status');

        const slotRandomUidToggle = document.getElementById('slot-random-uid-toggle');
        const slotWriteBtn = document.getElementById('slot-write-btn');
        const slotEmulateBtn = document.getElementById('slot-emulate-btn');
        const slotStatus = document.getElementById('slot-status');

        const NRF_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
        const UART_RX_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
        const UART_TX_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

        // Debug control system
        let DEBUG_MODE = false; // Can be changed at runtime

        // Global debug control functions (accessible from browser console)
        window.enableDebug = function() {
            DEBUG_MODE = true;
            console.log('🐛 Debug mode enabled - verbose logging is now on');
        };

        window.disableDebug = function() {
            DEBUG_MODE = false;
            console.log('🔇 Debug mode disabled - only errors will be shown');
        };

        // Debug logging functions
        function debugLog(...args) {
            if (DEBUG_MODE) {
                console.log(...args);
            }
        }

        function debugWarn(...args) {
            if (DEBUG_MODE) {
                console.warn(...args);
            }
        }

        function debugError(...args) {
            // Always show errors, even in production
            console.error(...args);
        }

        const CMD_SET_ACTIVE_SLOT = 1003;
        const CMD_GET_ACTIVE_SLOT = 1018;
        const CMD_GET_SLOT_INFO = 1019;
        const CMD_GET_ALL_SLOT_NICKS = 1038;
        const CMD_GET_ENABLED_SLOTS = 1023;
        const CMD_SET_SLOT_TAG_TYPE = 1004;
        const CMD_SET_SLOT_DATA_DEFAULT = 1005;
        const CMD_SET_SLOT_ENABLE = 1006;
        const CMD_DELETE_SLOT_INFO = 1024;
        const CMD_GET_BATTERY_INFO = 1025;
        const CMD_MF1_SET_ANTICOLLISION = 4001;

        // Tag type constants
        const TAG_TYPE_UNDEFINED = 0;
        const TAG_TYPE_NTAG_215 = 1101;
        const CMD_MF0_NTAG_WRITE_EMU_PAGE_DATA = 4022;
        const CMD_MF0_NTAG_READ_EMU_PAGE_DATA = 4021;
        const CMD_MF0_NTAG_GET_VERSION_DATA = 4023;
        const CMD_MF0_NTAG_SET_VERSION_DATA = 4024;
        const CMD_MF0_NTAG_GET_SIGNATURE_DATA = 4025;
        const CMD_MF0_NTAG_SET_SIGNATURE_DATA = 4026;
        const CMD_MF0_NTAG_SET_WRITE_MODE = 4032;
        const CMD_MF0_NTAG_SET_UID_MAGIC_MODE = 4020;
        const CMD_SLOT_DATA_CONFIG_SAVE = 1009;
        const CMD_SET_SLOT_TAG_NICK = 1007;
        const CMD_GET_SLOT_TAG_NICK = 1008;

        const TagType = { NTAG_215: 1101 };
        const TagFrequency = { HF: 2 }; // HF frequency value

        let ultra = null;
        let allAmiibos = [];
        let selectedAmiiboDetails = null; // Store the full details of the selected Amiibo
        let selectedSlotIndex = null; // Store the selected slot index
        let selectedSlotAmiiboDetails = null; // Store the Amiibo details for the selected slot
        let amiiboTemplate = null;
        let currentSlotNames = []; // Store slot names globally

        // Slot data caching system
        let slotDataCache = {}; // Cache slot data by slot index

        // Cache structure for each slot:
        // slotDataCache[slotIndex] = {
        //     slotName: "Amiibo Name",
        //     amiiboId: "2106000003601202",
        //     amiiboDetails: { name, series, image, etc },
        //     lastUpdated: timestamp,
        //     deviceSignature: "hash of device data for validation"
        // }

        // Maboii.js keys management
        let maboiiKeys = null;
        let keysLoaded = false;

        // Helper function to clean filename for nickname
        function cleanFilenameForNickname(filename) {
            // Remove file extension (.bin, .nfc, etc.)
            const nameWithoutExt = filename.replace(/\.[^/.]+$/, '');
            return nameWithoutExt;
        }

        // Slot data caching functions
        function generateDeviceSignature(slotName, amiiboId) {
            // Create a simple hash of the device data for cache validation
            return btoa(`${slotName}:${amiiboId}`).replace(/[^a-zA-Z0-9]/g, '');
        }

        function getCachedSlotData(slotIndex) {
            return slotDataCache[slotIndex] || null;
        }

        function setCachedSlotData(slotIndex, slotName, amiiboId, amiiboDetails) {
            slotDataCache[slotIndex] = {
                slotName: slotName,
                amiiboId: amiiboId,
                amiiboDetails: amiiboDetails,
                lastUpdated: Date.now(),
                deviceSignature: generateDeviceSignature(slotName, amiiboId)
            };
            debugLog(`💾 Cached data for slot ${slotIndex + 1}: ${slotName} (ID: ${amiiboId})`);
        }

        function validateCachedSlotData(slotIndex, currentSlotName, currentAmiiboId) {
            const cached = getCachedSlotData(slotIndex);
            if (!cached) return false;

            const currentSignature = generateDeviceSignature(currentSlotName, currentAmiiboId);
            const isValid = cached.deviceSignature === currentSignature;

            if (!isValid) {
                debugLog(`🔄 Cache invalid for slot ${slotIndex + 1}: cached="${cached.slotName}" vs current="${currentSlotName}"`);
                // Remove invalid cache entry
                delete slotDataCache[slotIndex];
            } else {
                debugLog(`✅ Cache valid for slot ${slotIndex + 1}: ${cached.slotName}`);
            }

            return isValid;
        }

        function clearSlotCache(slotIndex = null) {
            if (slotIndex !== null) {
                delete slotDataCache[slotIndex];
                debugLog(`🗑️ Cleared cache for slot ${slotIndex + 1}`);
            } else {
                slotDataCache = {};
                debugLog(`🗑️ Cleared all slot cache`);
            }
        }

        // No need to store IDs separately - we'll read from the card display

        // Notification system
        function showNotification(message, type = 'info', duration = 4000) {
            const container = document.getElementById('notification-container');

            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                padding: 15px 20px;
                margin-bottom: 10px;
                border-radius: 8px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                opacity: 0;
                transform: translateX(100%);
                transition: opacity 0.3s ease, transform 0.3s ease;
                display: flex;
                align-items: center;
                gap: 10px;
                font-size: 14px;
                line-height: 1.4;
            `;

            // Set colors based on type
            let icon = '';
            if (type === 'success') {
                notification.style.backgroundColor = '#d4edda';
                notification.style.color = '#155724';
                notification.style.border = '1px solid #c3e6cb';
                icon = '✓';
            } else if (type === 'error') {
                notification.style.backgroundColor = '#f8d7da';
                notification.style.color = '#721c24';
                notification.style.border = '1px solid #f5c6cb';
                icon = '✕';
            } else if (type === 'warning') {
                notification.style.backgroundColor = '#fff3cd';
                notification.style.color = '#856404';
                notification.style.border = '1px solid #ffeeba';
                icon = '⚠';
            } else {
                notification.style.backgroundColor = '#d1ecf1';
                notification.style.color = '#0c5460';
                notification.style.border = '1px solid #bee5eb';
                icon = 'ℹ';
            }

            // Add content
            notification.innerHTML = `
                <div style="font-size: 18px; font-weight: bold;">${icon}</div>
                <div style="flex: 1;">${message}</div>
                <button onclick="this.parentElement.remove()" style="
                    background: none;
                    border: none;
                    color: inherit;
                    font-size: 18px;
                    cursor: pointer;
                    padding: 0;
                    margin-left: 10px;
                    opacity: 0.6;
                    transition: opacity 0.2s;
                " onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.6'">×</button>
            `;

            // Add to container
            container.appendChild(notification);

            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 10);

            // Auto-remove after duration
            if (duration > 0) {
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => notification.remove(), 300);
                }, duration);
            }
        }

        // Load keys from localStorage if available
        function loadStoredKeys() {
            try {
                const storedKeys = localStorage.getItem('maboiiKeys');
                if (storedKeys) {
                    const keyData = JSON.parse(storedKeys);
                    maboiiKeys = keyData;
                    keysLoaded = true;
                    console.log('Maboii keys loaded from localStorage');
                    return true;
                }
            } catch (error) {
                console.error('Error loading stored keys:', error);
                localStorage.removeItem('maboiiKeys');
            }
            return false;
        }

        // Update key status UI and refresh slot cards to show/hide generation links
        async function updateKeyStatus() {
            if (keysLoaded && maboiiKeys) {
                keyStatus.style.backgroundColor = '#d4edda';
                keyStatus.style.color = '#155724';
                keyStatus.style.borderColor = '#c3e6cb';
                keyStatus.textContent = 'Keys loaded - ready to generate amiibo files ✓';
                clearKeysBtn.style.display = 'inline-block';
            } else {
                keyStatus.style.backgroundColor = '#f8d7da';
                keyStatus.style.color = '#721c24';
                keyStatus.style.borderColor = '#f5c6cb';
                keyStatus.textContent = 'Upload retail keys to generate amiibo files';
                clearKeysBtn.style.display = 'none';
            }

            // Refresh slot cards to show/hide generation-related links
            if (ultra && ultra.device && ultra.device.gatt.connected) {
                await refreshAmiiboSlots();
                if (allAmiibos.length > 0) {
                    await enhanceSlotCardsWithAmiiboInfo();
                }
            }
        }

        // Load keys from file
        async function loadKeysFromFile() {
            const file = keyFileInput.files[0];

            if (!file) {
                showNotification('Please select a key file first', 'warning');
                return;
            }

            if (file.name !== 'key_retail.bin' && !file.name.includes('key')) {
                if (!confirm('File name doesn\'t match expected key file format. Continue anyway?')) {
                    return;
                }
            }

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const keyBuffer = e.target.result;
                    const keyArray = Array.from(new Uint8Array(keyBuffer));

                    // Load keys with maboii
                    maboiiKeys = maboii.loadMasterKeys(keyArray);

                    if (!maboiiKeys) {
                        throw new Error('Invalid key file format');
                    }

                    keysLoaded = true;
                    // Save keys to localStorage
                    localStorage.setItem('maboiiKeys', JSON.stringify(maboiiKeys));
                    await updateKeyStatus();

                    showNotification('Keys loaded successfully! You can now generate encrypted amiibo files.', 'success');

                } catch (error) {
                    console.error('Error loading keys:', error);
                    showNotification('Error loading keys: ' + error.message, 'error');
                }
            };

            reader.onerror = function() {
                showNotification('Error reading file', 'error');
            };

            reader.readAsArrayBuffer(file);
        }

        // Clear stored keys
        async function clearKeys() {
            maboiiKeys = null;
            keysLoaded = false;
            localStorage.removeItem('maboiiKeys');
            await updateKeyStatus();
            keyFileInput.value = '';
            showNotification('Keys cleared successfully.', 'info');
        }
        let fixedUids = {}; // Store fixed UIDs for each Amiibo ID
        let importedBinFile = null; // Store the currently selected .bin/.nfc file data
        let importedBinFileName = ''; // Store the .bin/.nfc file name

        // Load saved preferences
        randomUidToggle.checked = localStorage.getItem('randomUidEnabled') !== 'false'; // Default to true
        slotRandomUidToggle.checked = localStorage.getItem('randomUidEnabled') !== 'false'; // Sync with main toggle

        // Load recent amiibos and favorites from localStorage (moved to after function definitions)

        function updateBatteryDisplay(voltage, percentage) {
            batteryText.textContent = `${percentage}%`;

            // Update icon based on percentage
            if (percentage <= 20) {
                batteryIcon.textContent = '🪫'; // Low battery
                batteryStatus.style.borderColor = '#dc3545';
                batteryStatus.style.background = 'rgba(255,240,240,0.9)';
            } else if (percentage <= 50) {
                batteryIcon.textContent = '🔋'; // Medium battery
                batteryStatus.style.borderColor = '#ffc107';
                batteryStatus.style.background = 'rgba(255,252,240,0.9)';
            } else {
                batteryIcon.textContent = '🔋'; // Good battery
                batteryStatus.style.borderColor = '#28a745';
                batteryStatus.style.background = 'rgba(240,255,240,0.9)';
            }

            batteryStatus.title = `Battery: ${percentage}% (${voltage}mV)`;
            batteryStatus.style.display = 'block';
        }

        function hideBatteryDisplay() {
            batteryStatus.style.display = 'none';
        }

        function onDisconnected() {
            console.log('Device disconnected');
            connectBtn.textContent = 'Connect to Chameleon Ultra';
            connectBtn.disabled = false;
            refreshSlotsBtn.style.display = 'none';
            hideBatteryDisplay();
            amiiboSlotsDiv.style.display = 'none';
            statusSection.style.display = 'none';
            closeModal(); // Close modal on disconnect
            if (ultra && ultra.device) {
                ultra.device.removeEventListener('gattserverdisconnected', onDisconnected);
            }
            ultra = null;
            setUploadStatus('Device disconnected', 'error');
        }

        function setUploadStatus(message, type = 'info') {
            uploadStatus.textContent = message;
            uploadStatus.className = ''; // Clear previous classes
            if (type === 'success') {
                uploadStatus.classList.add('success');
            } else if (type === 'error') {
                uploadStatus.classList.add('error');
            }
            statusSection.style.display = 'block';

            // Auto-hide success messages after 5 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusSection.style.display = 'none';
                }, 5000);
            }
        }

        function parseBinFile(data) {
            // NTAG215 can be 540 bytes (standard) or 572+ bytes (with signature)
            if (data.byteLength !== 540 && data.byteLength < 572) {
                throw new Error(`Invalid .bin file size: ${data.byteLength} bytes (expected 540 bytes for NTAG215 or 572+ bytes with signature)`);
            }

            const uint8Data = new Uint8Array(data);

            // Extract UID from first 9 bytes (7-byte UID + 2 check bytes)
            const uid = uint8Data.slice(0, 7);

            // Extract Amiibo ID from pages 21-22 (bytes 84-91)
            const amiiboId = uint8Data.slice(84, 92);

            // Convert to hex string for display
            const amiiboIdHex = Array.from(amiiboId).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();

            // Use ATQA values that match the GUI: [0, 68] = [0x00, 0x44]
            const atqa = new Uint8Array([0x00, 0x44]);

            // Extract SAK from the manufacturer data area (this is more complex for Amiibo)
            // For NTAG215, SAK should be 0x00
            const sak = 0x00;

            // Extract ATS (Answer To Select) - typically empty for NTAG215
            const ats = new Uint8Array([]);

            // Use the exact version data from the working slot configuration
            const ultralightVersion = new Uint8Array([0,4,4,2,1,0,17,3]);

            let signatureData = null;
            let fileType = 'standard';

            // Check if this is an extended dump with signature data
            if (data.byteLength >= 572) {
                // ECC signature is stored after the main NTAG215 data
                // Based on ChameleonMini source: ECC_SIGNATURE_AFTER_DUMP_OFFSET = 0x04
                // So signature starts at offset 540 + 4 = 544
                signatureData = uint8Data.slice(544, 544 + 32);
                fileType = 'extended';

                // Validate signature (check if it's not all zeros)
                const isEmptySignature = signatureData.every(byte => byte === 0);
                if (isEmptySignature) {
                    console.warn('Warning: ECC signature appears to be empty (all zeros)');
                }
            }

            return {
                fullData: uint8Data.slice(0, 540), // Only the main NTAG215 data
                uid: uid,
                amiiboId: amiiboId,
                amiiboIdHex: amiiboIdHex,
                atqa: atqa,
                sak: sak,
                ats: ats,
                ultralightVersion: ultralightVersion,
                signatureData: signatureData,
                fileType: fileType,
                size: data.byteLength,
                hasSignature: signatureData !== null
            };
        }

        function parseNfcFile(textData) {
            // Parse Flipper Zero .nfc file format
            const lines = textData.split('\n').map(line => line.trim()).filter(line => line.length > 0);

            let deviceType = '';
            let uid = [];
            let atqa = [];
            let sak = 0;
            let pages = [];
            let ultralightVersion = null;

            // Parse each line
            for (const line of lines) {
                if (line.startsWith('Device type:')) {
                    deviceType = line.split(':')[1].trim();
                } else if (line.startsWith('UID:')) {
                    uid = line.split(':')[1].trim().split(' ').map(hex => parseInt(hex, 16));
                } else if (line.startsWith('ATQA:')) {
                    atqa = line.split(':')[1].trim().split(' ').map(hex => parseInt(hex, 16));
                } else if (line.startsWith('SAK:')) {
                    sak = parseInt(line.split(':')[1].trim(), 16);
                } else if (line.startsWith('Mifare version:')) {
                    ultralightVersion = new Uint8Array(line.split(':')[1].trim().split(' ').map(hex => parseInt(hex, 16)));
                } else if (line.startsWith('Page ')) {
                    const match = line.match(/Page (\d+): (.+)/);
                    if (match) {
                        const pageNum = parseInt(match[1]);
                        const pageData = match[2].trim().split(' ').map(hex => parseInt(hex, 16));
                        pages[pageNum] = pageData;
                    }
                }
            }

            // Validate device type
            if (deviceType !== 'NTAG215') {
                throw new Error(`Unsupported device type: ${deviceType}. Only NTAG215 is supported.`);
            }

            // Validate we have enough pages (NTAG215 should have 135 pages, 0-134)
            if (pages.length < 135) {
                throw new Error(`Invalid .nfc file: Missing pages. Expected 135 pages, got ${pages.length}`);
            }

            // Convert pages to 540-byte data array
            const fullData = new Uint8Array(540);
            for (let i = 0; i < 135; i++) {
                if (pages[i]) {
                    for (let j = 0; j < 4; j++) {
                        fullData[i * 4 + j] = pages[i][j] || 0;
                    }
                }
            }

            // Extract Amiibo ID (pages 21-22, bytes 84-91)
            const amiiboId = fullData.slice(84, 92);
            const amiiboIdHex = Array.from(amiiboId, byte => byte.toString(16).padStart(2, '0')).join('').toUpperCase();

            return {
                fullData: fullData,
                uid: new Uint8Array(uid),
                amiiboId: amiiboId,
                amiiboIdHex: amiiboIdHex,
                atqa: new Uint8Array(atqa),
                sak: sak,
                ats: null, // NFC files don't typically include ATS
                ultralightVersion: ultralightVersion || new Uint8Array([0, 4, 4, 2, 1, 0, 17, 3]), // Default NTAG215 version
                signatureData: null, // NFC files don't include signatures
                fileType: 'nfc',
                size: 540,
                hasSignature: false
            };
        }

        function patchAmiiboData(binData) {
            // This function patches the Amiibo data similar to the Python patch.py script
            // It generates a password based on the UID and appends it with padding

            // If the file is already 540 bytes, check if it's already patched
            if (binData.fullData.length === 540) {
                // Check if last 8 bytes look like they've been patched
                const lastBytes = binData.fullData.slice(532);
                const hasValidPwd = lastBytes[4] === 0x80 && lastBytes[5] === 0x80;

                if (hasValidPwd) {
                    console.log('File appears to already be patched, using as-is');
                    return binData.fullData;
                }
            }

            // For patching, we only take the first 532 bytes and generate new password
            const dataFor532 = binData.fullData.slice(0, 532);

            // Extract UID components for password generation
            // Python: c[:3]+c[4:8] = bytes 0,1,2,4,5,6,7
            const uid = new Uint8Array(7);
            uid[0] = dataFor532[0];
            uid[1] = dataFor532[1];
            uid[2] = dataFor532[2];
            // Skip BCC0 at index 3
            uid[3] = dataFor532[4];
            uid[4] = dataFor532[5];
            uid[5] = dataFor532[6];
            uid[6] = dataFor532[7];

            // Generate password using the same algorithm as Python script
            const pwd = new Uint8Array(4);
            pwd[0] = (0xAA ^ uid[1] ^ uid[3]) & 0xFF;
            pwd[1] = (0x55 ^ uid[2] ^ uid[4]) & 0xFF;
            pwd[2] = (0xAA ^ uid[3] ^ uid[5]) & 0xFF;
            pwd[3] = (0x55 ^ uid[4] ^ uid[6]) & 0xFF;

            // Create the patched data
            const patchedData = new Uint8Array(540);

            // Copy the original 532 bytes
            patchedData.set(dataFor532, 0);

            // NTAG215 specific configuration for Switch compatibility
            // Page 131 (524-527): Configuration page 0
            // Page 132 (528-531): Configuration page 1
            // Keep original config pages but ensure proper AUTH0 setting

            // Page 133 (532-535): PWD (Password) - 4 bytes
            patchedData.set(pwd, 532);

            // Page 134 (536-539): PACK (Password Acknowledge) - 2 bytes + RFU (2 bytes)
            patchedData[536] = 0x80;  // PACK byte 0
            patchedData[537] = 0x80;  // PACK byte 1
            patchedData[538] = 0x00;  // RFU
            patchedData[539] = 0x00;  // RFU

            // Only set AUTH0 if it's not already set, preserve other config bytes
            if (patchedData[527] === 0x00 || patchedData[527] === 0xFF) {
                patchedData[527] = 0x04; // AUTH0: Pages 4+ require authentication
                console.log('Set AUTH0 to 0x04 for Amiibo compatibility');
            } else {
                console.log('AUTH0 already set to 0x' + patchedData[527].toString(16).padStart(2, '0'));
            }

            // Preserve original configuration bytes - don't override them
            console.log('Config pages preserved from original file');

            console.log('Patched Amiibo data:', {
                originalSize: binData.fullData.byteLength,
                patchedSize: patchedData.byteLength,
                password: Array.from(pwd).map(b => '0x' + b.toString(16).padStart(2, '0')).join(', '),
                uid: Array.from(uid).map(b => '0x' + b.toString(16).padStart(2, '0')).join(', '),
                firstBytes: Array.from(patchedData.slice(0, 16)).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '),
                lastBytes: Array.from(patchedData.slice(532, 540)).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')
            });

            return patchedData;
        }

        function setStatus(message, type = 'info') {
            status.textContent = message;
            status.className = ''; // Clear previous classes
            if (type === 'success') {
                status.classList.add('status-success');
            } else if (type === 'error') {
                status.classList.add('status-error');
            }
        }

        // Modal functions
        function openModal() {
            amiiboModal.style.display = 'flex'; // Use flex to center content
            updateSelectedSlotDetails(); // Update details when modal opens
        }

        function closeModal() {
            amiiboModal.style.display = 'none';
            setStatus(''); // Clear status message
        }

        // Slot modal functions
        function openSlotModal(slotIndex, amiiboDetails) {
            selectedSlotIndex = slotIndex;
            selectedSlotAmiiboDetails = amiiboDetails;

            // Populate slot details
            slotDetailSlot.textContent = `Slot ${slotIndex + 1}`;
            slotDetailName.textContent = amiiboDetails.name;
            slotDetailAmiiboSeries.textContent = amiiboDetails.amiiboSeries;
            slotDetailGameSeries.textContent = amiiboDetails.gameSeries;
            slotDetailReleaseNa.textContent = amiiboDetails.release.na || 'N/A';
            slotDetailReleaseEu.textContent = amiiboDetails.release.eu || 'N/A';
            slotDetailReleaseJp.textContent = amiiboDetails.release.jp || 'N/A';
            slotDetailReleaseAu.textContent = amiiboDetails.release.au || 'N/A';
            slotDetailsImage.src = amiiboDetails.image;

            slotModal.style.display = 'flex';
        }

        function closeSlotModal() {
            slotModal.style.display = 'none';
            setSlotStatus(''); // Clear status message
        }

        function setSlotStatus(message, type = 'info') {
            slotStatus.textContent = message;
            slotStatus.className = ''; // Clear previous classes
            if (type === 'success') {
                slotStatus.classList.add('status-success');
            } else if (type === 'error') {
                slotStatus.classList.add('status-error');
            }
        }

        // Modal functions for Clear Slot
        function openClearSlotModal(slotIndex, slotName) {
            clearSlotName.textContent = `${slotName} (Slot ${slotIndex + 1})`;
            clearSlotModal.style.display = 'flex';

            // Store slot index for the confirm action
            clearConfirmBtn.dataset.slotIndex = slotIndex;
        }

        function closeClearSlotModal() {
            clearSlotModal.style.display = 'none';
            delete clearConfirmBtn.dataset.slotIndex;
        }

        // Modal functions for Download
        function openDownloadModal(slotIndex, slotName) {
            downloadSlotName.textContent = `${slotName} (Slot ${slotIndex + 1})`;
            downloadModal.style.display = 'flex';
        }

        function closeDownloadModal() {
            downloadModal.style.display = 'none';
        }

        // Upload modal functions
        let uploadTargetSlot = null;

        function openUploadModal(slotIndex, slotName) {
            uploadTargetSlot = slotIndex;
            uploadSlotName.textContent = `${slotName} (Slot ${slotIndex + 1})`;
            uploadModal.style.display = 'flex';
            uploadFileInput.value = '';
            uploadModalStatus.style.display = 'none';

            // Show randomize UID option only when keys are available
            if (keysLoaded && maboiiKeys) {
                uploadRandomizeSection.style.display = 'block';
                uploadRandomizeUid.checked = localStorage.getItem('randomUidEnabled') !== 'false'; // Use saved preference
            } else {
                uploadRandomizeSection.style.display = 'none';
                uploadRandomizeUid.checked = false; // Force unchecked when no keys
            }
        }

        function closeUploadModal() {
            uploadModal.style.display = 'none';
            uploadTargetSlot = null;
            uploadFileInput.value = '';
            uploadModalStatus.style.display = 'none';
        }

        function setUploadModalStatus(message, type = 'info') {
            uploadModalStatus.style.display = 'block';
            uploadModalStatus.textContent = message;
            uploadModalStatus.className = '';

            if (type === 'success') {
                uploadModalStatus.style.backgroundColor = '#d4edda';
                uploadModalStatus.style.color = '#155724';
                uploadModalStatus.style.borderColor = '#c3e6cb';
            } else if (type === 'error') {
                uploadModalStatus.style.backgroundColor = '#f8d7da';
                uploadModalStatus.style.color = '#721c24';
                uploadModalStatus.style.borderColor = '#f5c6cb';
            } else {
                uploadModalStatus.style.backgroundColor = '#d1ecf1';
                uploadModalStatus.style.color = '#0c5460';
                uploadModalStatus.style.borderColor = '#bee5eb';
            }
        }

        // Upload with optional UID randomization
        async function uploadBinToSlotWithRandomize(file, slotIndex, randomizeUid = false) {
            // Use existing uploadBinToSlot logic but with optional randomization
            const isNfcFile = file.name.toLowerCase().endsWith('.nfc');

            updateUploadProgress('Processing file...', 50, `Reading ${isNfcFile ? '.nfc' : '.bin'} file`);

            // Only attempt randomization if keys are available
            if (randomizeUid && keysLoaded && maboiiKeys) {
                // Parse the file to get amiibo ID
                const parsedBin = isNfcFile ?
                    parseNfcFile(await file.text()) :
                    await parseBinFile(await file.arrayBuffer(), file.name);

                updateUploadProgress('Extracting amiibo ID...', 70, 'Reading amiibo data for UID randomization');
                const amiiboIdHex = extractAmiiboIdFromBinData(parsedBin.fullData);

                if (amiiboIdHex && amiiboIdHex !== '0000000000000000') {
                    console.log(`Randomizing UID for amiibo ID: ${amiiboIdHex}`);
                    updateUploadProgress('Generating new UID...', 90, 'Creating fresh amiibo with random UID');
                    // Generate fresh amiibo with same ID but new UID
                    const generatedData = await generateEncryptedAmiiboData(amiiboIdHex);

                    updateUploadProgress('Writing to device...', 90, `Uploading to slot ${slotIndex + 1} with random UID`);
                    await ultra.writeBinToSlot(slotIndex, generatedData.pageData, cleanFilenameForNickname(file.name), null, new Uint8Array([0, 4, 4, 2, 1, 0, 17, 3]));
                } else {
                    // Fallback to normal upload if ID extraction fails
                    console.log('Could not extract amiibo ID, using normal upload');
                    updateUploadProgress('Patching data...', 70, 'Optimizing for Nintendo Switch compatibility');
                    const patchedData = patchAmiiboData(parsedBin);

                    updateUploadProgress('Writing to device...', 90, `Uploading to slot ${slotIndex + 1}`);
                    await ultra.writeBinToSlot(slotIndex, patchedData, cleanFilenameForNickname(file.name), parsedBin.signatureData, parsedBin.ultralightVersion);
                }
            } else {
                // Normal upload without randomization
                const parsedBin = isNfcFile ?
                    parseNfcFile(await file.text()) :
                    await parseBinFile(await file.arrayBuffer(), file.name);

                updateUploadProgress('Patching data...', 70, 'Optimizing for Nintendo Switch compatibility');
                const patchedData = patchAmiiboData(parsedBin);

                updateUploadProgress('Writing to device...', 90, `Uploading to slot ${slotIndex + 1}`);
                await ultra.writeBinToSlot(slotIndex, patchedData, cleanFilenameForNickname(file.name), parsedBin.signatureData, parsedBin.ultralightVersion);
            }

            updateUploadProgress('Upload complete!', 100, 'Amiibo successfully written to device');

            // Close progress modal immediately and show success
            setTimeout(() => {
                hideUploadProgress();
                setUploadStatus(`Successfully uploaded ${file.name} to slot ${slotIndex + 1}`, 'success');
            }, 1000);

            // Refresh the slots display in background (non-blocking)
            // Add longer delay to ensure device has fully processed the nickname update
            setTimeout(async () => {
                console.log('🔄 Refreshing slots display after upload...');
                await refreshAmiiboSlots();
                if (allAmiibos.length > 0) {
                    await enhanceSlotCardsWithAmiiboInfo();
                }
            }, 3000);  // Increased delay from 1500ms to 3000ms
        }

        // Extract amiibo ID from bin data
        function extractAmiiboIdFromBinData(binData) {
            if (binData.length >= 92) {
                // Amiibo ID is typically at offset 84-91 (8 bytes)
                const idBytes = Array.from(binData.slice(84, 92));
                return idBytes.map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();
            }
            return null;
        }

        // Randomize & Emulate function - reads current emulated data and randomizes UID
        async function randomizeAndEmulate(slotIndex, slotName) {
            try {
                // Check if keys are available
                if (!keysLoaded || !maboiiKeys) {
                    throw new Error('Retail keys are required for UID randomization');
                }

                showUploadProgress(`Reading emulated data from ${slotName}`, 20, 'Reading current emulation...');

                // First activate the slot to ensure we're reading the right data
                const activateSlotData = new Uint8Array([slotIndex]);
                await ultra.sendCommand(CMD_SET_ACTIVE_SLOT, activateSlotData);

                // Small delay to ensure slot is active
                await new Promise(resolve => setTimeout(resolve, 100));

                // Read the current emulated data
                const currentData = await ultra.readCurrentEmulatedData();

                if (!currentData.amiiboId || currentData.amiiboId === '0000000000000000') {
                    throw new Error('Cannot randomize: No valid amiibo data in emulated slot');
                }

                updateUploadProgress('Generating new UID...', 50, 'Creating fresh UID while preserving amiibo ID');

                // Generate fresh amiibo data with same ID but new random UID
                const generatedData = await generateEncryptedAmiiboData(currentData.amiiboId);

                updateUploadProgress('Starting emulation with new UID...', 90, 'Emulating with randomized UID');

                // Emulate with the new UID
                await ultra.emulateNtag215(slotIndex, generatedData.pageData, generatedData.uid);

                updateUploadProgress('Emulation updated!', 100, 'Successfully randomized UID and restarted emulation');

                setTimeout(() => {
                    hideUploadProgress();
                    setUploadStatus(`Successfully randomized UID and emulating ${slotName} on slot ${slotIndex + 1}`, 'success');
                    refreshAmiiboSlots(); // Refresh slots
                }, 1500);

            } catch (error) {
                hideUploadProgress();
                setUploadStatus(`Randomize & Emulate failed: ${error.message}`, 'error');
            }
        }

        // Randomize UID function - generates fresh amiibo with same ID from card display
        async function randomizeSlotUID(slotIndex, slotName, amiiboId = null) {
            try {
                // Check if keys are available
                if (!keysLoaded || !maboiiKeys) {
                    throw new Error('Retail keys are required for UID randomization');
                }

                showUploadProgress(`Randomizing UID for ${slotName}`, 20, 'Using amiibo ID from card...');

                if (!amiiboId) {
                    throw new Error('Cannot randomize UID: No amiibo ID found on card display');
                }

                console.log(`Using amiibo ID from card: ${amiiboId}`);

                if (amiiboId === '0000000000000000') {
                    throw new Error('Cannot randomize UID: Invalid amiibo ID');
                }

                updateUploadProgress('Generating new amiibo with fresh UID...', 70, 'Creating amiibo with same ID, new UID');

                // Generate fresh amiibo data with same ID but new random UID
                // Remove the '0x' prefix if present and use the ID directly
                const cleanAmiiboId = amiiboId.replace(/^0x/i, '');
                const generatedData = await generateEncryptedAmiiboData(cleanAmiiboId);

                updateUploadProgress('Writing updated amiibo...', 90, 'Writing amiibo with new UID to device');

                // Write the newly generated data with fresh UID
                await ultra.writeBinToSlot(slotIndex, generatedData.pageData, slotName, null, new Uint8Array([0, 4, 4, 2, 1, 0, 17, 3]));

                updateUploadProgress('UID randomized!', 100, 'Successfully generated with new random UID');

                // Close progress modal immediately and show success
                setTimeout(() => {
                    hideUploadProgress();
                    setUploadStatus(`Successfully randomized UID for ${slotName}`, 'success');
                }, 1000);

                // Refresh the slots display in background (non-blocking)
                setTimeout(async () => {
                    await refreshAmiiboSlots();
                    if (allAmiibos.length > 0) {
                        await enhanceSlotCardsWithAmiiboInfo();
                    }
                }, 1500);

            } catch (error) {
                console.error('Error randomizing UID:', error);
                hideUploadProgress();
                setUploadStatus(`Failed to randomize UID for ${slotName}: ${error.message}`, 'error');
            }
        }

        // Modal functions for Generate Amiibo
        let selectedAmiiboForGeneration = null;
        let generateTargetSlot = null;
        let recentAmiibos = [];
        let favoriteAmiibos = [];
        const MAX_RECENT_AMIIBOS = 10;
        const MAX_FAVORITE_AMIIBOS = 20;

        // Helper functions for amiibo data
        function getAmiiboHead(amiibo) {
            return amiibo.head || amiibo.id.slice(0, 8);
        }

        function getAmiiboTail(amiibo) {
            return amiibo.tail || amiibo.id.slice(8, 16);
        }

        function getAmiiboId(amiibo) {
            return amiibo.id || (amiibo.head + amiibo.tail);
        }

        // Normalize stored amiibo objects to include head/tail if missing
        function normalizeStoredAmiibo(amiibo) {
            return {
                ...amiibo,
                head: getAmiiboHead(amiibo),
                tail: getAmiiboTail(amiibo),
                id: getAmiiboId(amiibo)
            };
        }

        // Recent Amiibos Management
        function loadRecentAmiibos() {
            try {
                const stored = localStorage.getItem('recentAmiibos');
                if (stored) {
                    recentAmiibos = JSON.parse(stored);
                    // Ensure we have valid data
                    recentAmiibos = recentAmiibos.filter(a => a && a.id && a.name).slice(0, MAX_RECENT_AMIIBOS);
                }
            } catch (error) {
                console.error('Failed to load recent amiibos:', error);
                recentAmiibos = [];
            }
        }

        function saveRecentAmiibo(amiibo) {
            if (!amiibo || !getAmiiboId(amiibo)) return;

            const amiiboData = {
                id: getAmiiboId(amiibo),
                name: amiibo.name,
                image: amiibo.image,
                gameSeries: amiibo.gameSeries,
                amiiboSeries: amiibo.amiiboSeries
            };

            // Remove if already exists
            recentAmiibos = recentAmiibos.filter(a => a.id !== amiiboData.id);

            // Add to beginning
            recentAmiibos.unshift(amiiboData);

            // Keep only MAX_RECENT_AMIIBOS
            recentAmiibos = recentAmiibos.slice(0, MAX_RECENT_AMIIBOS);

            // Save to localStorage
            try {
                localStorage.setItem('recentAmiibos', JSON.stringify(recentAmiibos));
            } catch (error) {
                console.error('Failed to save recent amiibos:', error);
            }
        }

        function displayRecentAmiibos() {
            const container = document.getElementById('recent-amiibos-container');
            if (!container) return;

            // Clear existing content
            container.innerHTML = '';

            if (recentAmiibos.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #999; width: 100%; padding: 40px 0;">No recent amiibos</div>';
                return;
            }

            // Create cards for each recent amiibo
            recentAmiibos.forEach(amiibo => {
                const card = document.createElement('div');
                card.className = 'recent-amiibo-card';
                const isFavorited = isAmiiboFavorited(amiibo.id);

                card.innerHTML = `
                    <img src="${amiibo.image}" alt="${amiibo.name}" onerror="this.src='data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'60\' height=\'60\' fill=\'%23ccc\'><rect width=\'60\' height=\'60\' fill=\'%23f0f0f0\'/><text x=\'50%\' y=\'50%\' text-anchor=\'middle\' dy=\'.3em\' fill=\'%23999\' font-family=\'sans-serif\' font-size=\'10\'>No Image</text></svg>'">
                    <div class="name">${amiibo.name}</div>
                `;

                // Card click handler
                card.addEventListener('click', () => {
                    // Select this amiibo
                    selectAmiiboForGeneration(amiibo);

                    // Switch to search tab to show selection
                    switchTab('search');

                    // Update UI to show selected
                    document.querySelectorAll('.recent-amiibo-card, .favorite-amiibo-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                });

                container.appendChild(card);
            });
        }


        function openGenerateModal(slotIndex, slotName) {
            generateTargetSlot = slotIndex;
            document.getElementById('generate-slot-name').textContent = `${slotName} (Slot ${slotIndex + 1})`;
            document.getElementById('generateModal').style.display = 'flex';

            // Reset the modal state
            selectedAmiiboForGeneration = null;
            document.getElementById('selected-amiibo-section').style.display = 'none';
            document.getElementById('amiibo-search-results').style.display = 'none';
            document.getElementById('amiibo-search').value = '';

            // Load and display recent amiibos and favorites
            loadRecentAmiibos();
            loadFavoriteAmiibos();
            displayRecentAmiibos();
            displayFavoriteAmiibos();

            // Default to recent tab
            switchTab('recent');

            // Setup tab event listeners if not already done
            if (!window.tabEventListenersSetup) {
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const tabName = btn.getAttribute('data-tab');
                        switchTab(tabName);
                    });
                });
                window.tabEventListenersSetup = true;
            }
            resultsInfo.style.display = 'none';
            gameSeriesFilter.value = '';
            sortOption.value = 'newest';

            // Load amiibo database and show all amiibos immediately
            loadAmiiboDatabase().then(() => {
                performSearch(''); // Show all amiibos on modal open
            });

            // Focus on search after a brief delay to ensure modal is rendered
            setTimeout(() => {
                document.getElementById('amiibo-search').focus();
            }, 100);
        }

        function closeGenerateModal() {
            document.getElementById('generateModal').style.display = 'none';
            selectedAmiiboForGeneration = null;
            generateTargetSlot = null;
        }

        function selectAmiiboForGeneration(amiibo) {
            selectedAmiiboForGeneration = amiibo;

            // Update selected amiibo display
            document.getElementById('selected-amiibo-name').textContent = amiibo.name;
            document.getElementById('selected-amiibo-series').textContent = amiibo.amiiboSeries;
            document.getElementById('selected-amiibo-id').textContent = getAmiiboId(amiibo);
            document.getElementById('selected-amiibo-image').src = amiibo.image;

            // Update favorite checkbox state
            const favoriteCheckbox = document.getElementById('favorite-checkbox');
            const amiiboId = getAmiiboId(amiibo);
            favoriteCheckbox.checked = isAmiiboFavorited(amiiboId);

            // Setup checkbox event listener (remove previous listener if exists)
            const newCheckbox = favoriteCheckbox.cloneNode(true);
            favoriteCheckbox.parentNode.replaceChild(newCheckbox, favoriteCheckbox);

            newCheckbox.addEventListener('change', () => {
                if (newCheckbox.checked) {
                    saveFavoriteAmiibo(amiibo);
                } else {
                    removeFavoriteAmiibo(getAmiiboId(amiibo));
                }
                // Refresh favorites display
                displayFavoriteAmiibos();
            });

            // Show selected section and hide search results
            document.getElementById('selected-amiibo-section').style.display = 'block';
            document.getElementById('amiibo-search-results').style.display = 'none';

            // Clear previous selections in cards
            document.querySelectorAll('.recent-amiibo-card, .favorite-amiibo-card').forEach(c => c.classList.remove('selected'));

            // Amiibo is now selected and visible in the UI
        }

        // Favorites Management
        function loadFavoriteAmiibos() {
            try {
                const stored = localStorage.getItem('favoriteAmiibos');
                if (stored) {
                    favoriteAmiibos = JSON.parse(stored);
                    // Ensure we have valid data
                    favoriteAmiibos = favoriteAmiibos.filter(a => a && a.id && a.name).slice(0, MAX_FAVORITE_AMIIBOS);
                }
            } catch (error) {
                console.error('Failed to load favorite amiibos:', error);
                favoriteAmiibos = [];
            }
        }

        function saveFavoriteAmiibo(amiibo) {
            if (!amiibo || !getAmiiboId(amiibo)) return;

            const amiiboData = {
                id: getAmiiboId(amiibo),
                name: amiibo.name,
                image: amiibo.image,
                gameSeries: amiibo.gameSeries,
                amiiboSeries: amiibo.amiiboSeries
            };

            // Don't add duplicates
            if (!favoriteAmiibos.some(a => a.id === amiiboData.id)) {
                favoriteAmiibos.push(amiiboData);

                // Keep only MAX_FAVORITE_AMIIBOS
                favoriteAmiibos = favoriteAmiibos.slice(0, MAX_FAVORITE_AMIIBOS);

                // Save to localStorage
                try {
                    localStorage.setItem('favoriteAmiibos', JSON.stringify(favoriteAmiibos));
                } catch (error) {
                    console.error('Failed to save favorite amiibos:', error);
                }

                return true; // Successfully added
            }
            return false; // Already favorited
        }

        function removeFavoriteAmiibo(amiiboId) {
            favoriteAmiibos = favoriteAmiibos.filter(a => a.id !== amiiboId);

            // Save to localStorage
            try {
                localStorage.setItem('favoriteAmiibos', JSON.stringify(favoriteAmiibos));
            } catch (error) {
                console.error('Failed to save favorite amiibos:', error);
            }
        }

        function isAmiiboFavorited(amiiboId) {
            return favoriteAmiibos.some(a => a.id === amiiboId);
        }

        function toggleFavorite(amiibo) {
            const amiiboId = getAmiiboId(amiibo);
            if (isAmiiboFavorited(amiiboId)) {
                removeFavoriteAmiibo(amiiboId);
                return false; // Removed from favorites
            } else {
                saveFavoriteAmiibo(amiibo);
                return true; // Added to favorites
            }
        }

        function displayFavoriteAmiibos() {
            const container = document.getElementById('favorites-amiibos-container');
            if (!container) return;

            // Clear existing content
            container.innerHTML = '';

            if (favoriteAmiibos.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #999; width: 100%; padding: 40px 0;">No favorite amiibos<br><small>Star amiibos to add them to favorites</small></div>';
                return;
            }

            // Create cards for each favorite amiibo
            favoriteAmiibos.forEach(amiibo => {
                const card = document.createElement('div');
                card.className = 'recent-amiibo-card favorite-amiibo-card';
                card.innerHTML = `
                    <img src="${amiibo.image}" alt="${amiibo.name}" onerror="this.src='data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'60\' height=\'60\' fill=\'%23ccc\'><rect width=\'60\' height=\'60\' fill=\'%23f0f0f0\'/><text x=\'50%\' y=\'50%\' text-anchor=\'middle\' dy=\'.3em\' fill=\'%23999\' font-family=\'sans-serif\' font-size=\'10\'>No Image</text></svg>'">
                    <div class="name">${amiibo.name}</div>
                    <div style="position: absolute; top: 5px; right: 5px; color: #ffc107; font-size: 12px;">⭐</div>
                `;

                // Card click handler
                card.addEventListener('click', () => {
                    // Select this amiibo
                    selectAmiiboForGeneration(amiibo);

                    // Switch to search tab to show selected amiibo
                    switchTab('search');

                    // Update UI to show selected
                    document.querySelectorAll('.recent-amiibo-card, .favorite-amiibo-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                });

                // Add context menu for removing favorites
                card.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (confirm(`Remove ${amiibo.name} from favorites?`)) {
                        removeFavoriteAmiibo(amiibo.id);
                        displayFavoriteAmiibos(); // Refresh display
                    }
                });

                container.appendChild(card);
            });
        }

        // Tab Management
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });

            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab content
            const selectedContent = document.getElementById(`${tabName}-tab`);
            if (selectedContent) {
                selectedContent.classList.add('active');
            }

            // Add active class to selected tab button
            const selectedBtn = document.querySelector(`[data-tab="${tabName}"]`);
            if (selectedBtn) {
                selectedBtn.classList.add('active');
            }
        }



        // Upload Progress Modal functions
        function showUploadProgress(message, percent = 0, details = '', title = 'Processing...') {
            uploadProgressTitle.textContent = title;
            uploadProgressMessage.textContent = message;
            uploadProgressBar.style.width = percent + '%';
            uploadProgressPercent.textContent = Math.round(percent) + '%';
            uploadDetails.textContent = details;
            uploadProgressModal.style.display = 'flex';
        }

        function updateUploadProgress(message, percent, details = '') {
            uploadProgressMessage.textContent = message;
            uploadProgressBar.style.width = percent + '%';
            uploadProgressPercent.textContent = Math.round(percent) + '%';
            if (details) {
                uploadDetails.textContent = details;
            }
        }

        function hideUploadProgress() {
            uploadProgressModal.style.display = 'none';
        }

        class ChameleonUltra {
            constructor() {
                this.device = null;
                this.rxCharacteristic = null;
                this.responseCallback = null;
                this.responseBuffer = new Uint8Array();
            }

            async connect() {
                this.device = await navigator.bluetooth.requestDevice({ filters: [{ services: [NRF_SERVICE_UUID] }] });
                this.device.addEventListener('gattserverdisconnected', onDisconnected);
                const server = await this.device.gatt.connect();
                const service = await server.getPrimaryService(NRF_SERVICE_UUID);
                this.rxCharacteristic = await service.getCharacteristic(UART_RX_UUID);
                const txCharacteristic = await service.getCharacteristic(UART_TX_UUID);
                await txCharacteristic.startNotifications();
                txCharacteristic.addEventListener('characteristicvaluechanged', this.handleNotifications.bind(this));
            }

            handleNotifications(event) {
                const value = new Uint8Array(event.target.value.buffer);
                const newBuffer = new Uint8Array(this.responseBuffer.length + value.length);
                newBuffer.set(this.responseBuffer);
                newBuffer.set(value, this.responseBuffer.length);
                this.responseBuffer = newBuffer;

                const sofIndex = this.responseBuffer.indexOf(0x11);
                if (sofIndex === -1 || this.responseBuffer[sofIndex + 1] !== 0xEF) return;
                if (this.responseBuffer.length < 10) return;

                const frameView = new DataView(this.responseBuffer.buffer);
                const dataLen = frameView.getUint16(sofIndex + 6, false);
                const frameLen = 10 + dataLen;

                if (this.responseBuffer.length >= sofIndex + frameLen) {
                    const frame = this.responseBuffer.slice(sofIndex, sofIndex + frameLen);
                    if (this.responseCallback) {
                        this.responseCallback(new DataView(frame.buffer));
                        this.responseCallback = null;
                    }
                    this.responseBuffer = this.responseBuffer.slice(sofIndex + frameLen);
                }
            }

            lrcCalc(data) {
                let ret = 0x00;
                for (const b of data) { ret = (ret + b) & 0xFF; }
                return (0x100 - ret) & 0xFF;
            }

            async sendCommand(cmd, data = new Uint8Array()) {
                return new Promise(async (resolve, reject) => {
                    if (!this.device || !this.device.gatt.connected) {
                        onDisconnected();
                        return reject(new Error('Device not connected'));
                    }

                    const header = new Uint8Array(6);
                    const view = new DataView(header.buffer);
                    view.setUint16(0, cmd, false);
                    view.setUint16(2, 0, false);
                    view.setUint16(4, data.length, false);

                    const frame = new Uint8Array(10 + data.length);
                    frame.set([0x11, 0xEF], 0);
                    frame.set(header, 2);
                    frame[8] = this.lrcCalc(Array.from(frame.slice(2, 8)));
                    frame.set(data, 9);
                    frame[frame.length - 1] = this.lrcCalc(Array.from(frame.slice(9, -1)));

                    this.responseCallback = (response) => {
                        const responseData = new DataView(response.buffer, 9, response.byteLength - 10);
                        resolve(responseData);
                    };

                    setTimeout(() => reject(new Error('Command timed out')), 5000);
                    await this.rxCharacteristic.writeValue(frame);
                });
            }

            async getSlotNames() {
                const response = await this.sendCommand(CMD_GET_ALL_SLOT_NICKS);
                const slots = [];
                let offset = 0;
                const textDecoder = new TextDecoder();
                for (let i = 0; i < 8; i++) {
                    const hfLen = response.getUint8(offset++);
                    const hfName = hfLen > 0 ? textDecoder.decode(new Uint8Array(response.buffer, response.byteOffset + offset, hfLen)) : '';
                    offset += hfLen;
                    const lfLen = response.getUint8(offset++);
                    const lfName = lfLen > 0 ? textDecoder.decode(new Uint8Array(response.buffer, response.byteOffset + offset, lfLen)) : '';
                    offset += lfLen;
                    slots.push({ hfName, lfName });
                }
                return slots;
            }

            async getActiveSlot() {
                const response = await this.sendCommand(CMD_GET_ACTIVE_SLOT);
                return response.getUint8(0);
            }

            async _writeNtag215(slot, data, uid) {
                const setTypeData = new Uint8Array(3);
                const setTypeView = new DataView(setTypeData.buffer);
                setTypeView.setUint8(0, slot);
                setTypeView.setUint16(1, TagType.NTAG_215, false);
                await this.sendCommand(CMD_SET_SLOT_TAG_TYPE, setTypeData);

                const setDefaultData = new Uint8Array(3);
                const setDefaultView = new DataView(setDefaultData.buffer);
                setDefaultView.setUint8(0, slot);
                setDefaultView.setUint16(1, TagType.NTAG_215, false);
                await this.sendCommand(CMD_SET_SLOT_DATA_DEFAULT, setDefaultData);

                const atqa = new Uint8Array([0x00, 0x44]);
                const sak = 0x00;
                const ats = new Uint8Array([]);
                const antiCollData = new Uint8Array(1 + uid.length + atqa.length + 1 + ats.length);
                let offset = 0;
                antiCollData[offset++] = uid.length;
                antiCollData.set(uid, offset); offset += uid.length;
                antiCollData.set(atqa, offset); offset += atqa.length;
                antiCollData[offset++] = sak;
                antiCollData[offset++] = ats.length;
                if (ats.length > 0) antiCollData.set(ats, offset);
                await this.sendCommand(CMD_MF1_SET_ANTICOLLISION, antiCollData);

                const pageSize = 4;
                for (let i = 0; i < data.length; i += pageSize) {
                    const page = i / pageSize;
                    let chunk = data.slice(i, i + pageSize);
                    if (chunk.length < pageSize) {
                        const paddedChunk = new Uint8Array(pageSize);
                        paddedChunk.set(chunk);
                        chunk = paddedChunk;
                    }
                    const writeData = new Uint8Array(2 + chunk.length);
                    const writeView = new DataView(writeData.buffer);
                    writeView.setUint8(0, page);
                    writeView.setUint8(1, 1);
                    writeData.set(chunk, 2);
                    await this.sendCommand(CMD_MF0_NTAG_WRITE_EMU_PAGE_DATA, writeData);
                }
            }

            async writeNtag215ToSlot(slot, data, uid, name) {
                // First set the slot as active to ensure it's properly initialized
                const activateSlotData = new Uint8Array([slot]);
                await this.sendCommand(CMD_SET_ACTIVE_SLOT, activateSlotData);

                // Write the NTAG215 data
                await this._writeNtag215(slot, data, uid);

                // Enable the slot for HF frequency
                const enableSlotData = new Uint8Array([slot, TagFrequency.HF, 1]); // slot, frequency, enable(1)
                await this.sendCommand(CMD_SET_SLOT_ENABLE, enableSlotData);

                // Set the slot nickname
                const textEncoder = new TextEncoder();
                let nameBytes = textEncoder.encode(name);
                if (nameBytes.length > 255) {
                    nameBytes = nameBytes.slice(0, 255);
                }
                const setNameData = new Uint8Array(2 + nameBytes.length);
                setNameData[0] = slot;
                setNameData[1] = TagFrequency.HF; // HF frequency
                setNameData.set(nameBytes, 2);
                await this.sendCommand(CMD_SET_SLOT_TAG_NICK, setNameData);

                // Save the configuration
                await this.sendCommand(CMD_SLOT_DATA_CONFIG_SAVE);
            }

            async emulateNtag215(slot, data, uid) {
                const activateSlotData = new Uint8Array([slot]);
                await this.sendCommand(CMD_SET_ACTIVE_SLOT, activateSlotData);
                await this._writeNtag215(slot, data, uid);
            }

            async setSignatureData(signatureData) {
                if (signatureData.length !== 32) {
                    throw new Error(`Invalid signature data length: ${signatureData.length} bytes (expected 32 bytes)`);
                }
                await this.sendCommand(CMD_MF0_NTAG_SET_SIGNATURE_DATA, signatureData);
            }

            async getSignatureData() {
                const response = await this.sendCommand(CMD_MF0_NTAG_GET_SIGNATURE_DATA);
                return new Uint8Array(response.buffer, response.byteOffset, 32);
            }

            async setVersionData(versionData) {
                if (versionData.length !== 8) {
                    throw new Error(`Invalid version data length: ${versionData.length} bytes (expected 8 bytes)`);
                }
                await this.sendCommand(CMD_MF0_NTAG_SET_VERSION_DATA, versionData);
            }

            async getVersionData() {
                const response = await this.sendCommand(CMD_MF0_NTAG_GET_VERSION_DATA);
                return new Uint8Array(response.buffer, response.byteOffset, 8);
            }

            async getBatteryInfo() {
                const response = await this.sendCommand(CMD_GET_BATTERY_INFO);
                console.log('Battery response bytes:', Array.from(new Uint8Array(response.buffer)).map(b => `0x${b.toString(16).padStart(2, '0')}`));
                const voltage = response.getUint16(0, false); // Big endian (false)
                const percentage = response.getUint8(2);
                console.log('Parsed battery data:', { voltage, percentage });
                return { voltage, percentage };
            }

            async readNtagPages(startPage, numPages) {
                const readData = new Uint8Array([startPage, numPages]);
                const response = await this.sendCommand(CMD_MF0_NTAG_READ_EMU_PAGE_DATA, readData);
                return new Uint8Array(response.buffer, response.byteOffset, response.byteLength);
            }

            async readCurrentEmulatedData() {
                try {
                    // Read all 135 pages of NTAG215 (540 bytes)
                    const fullData = new Uint8Array(540);
                    const pagesPerRead = 60; // Read 60 pages at a time (240 bytes)

                    for (let i = 0; i < 135; i += pagesPerRead) {
                        const pagesToRead = Math.min(pagesPerRead, 135 - i);
                        const pageData = await this.readNtagPages(i, pagesToRead);
                        fullData.set(pageData, i * 4);
                    }

                    // Extract UID from pages 0-1 (first 8 bytes)
                    const uid = fullData.slice(0, 7);

                    // Extract Amiibo ID from pages 21-22 (bytes 84-91)
                    const amiiboId = fullData.slice(84, 92);

                    return {
                        fullData: fullData,
                        uid: uid,
                        amiiboId: Array.from(amiiboId).map(b => b.toString(16).padStart(2, '0')).join('')
                    };
                } catch (error) {
                    console.error('Failed to read emulated data:', error);
                    throw error;
                }
            }

            async writeBinToSlot(slot, binData, name, signatureData = null, versionData = null) {
                // First set the slot as active to ensure it's properly initialized
                const activateSlotData = new Uint8Array([slot]);
                await this.sendCommand(CMD_SET_ACTIVE_SLOT, activateSlotData);

                // Set slot type to NTAG_215
                const setTypeData = new Uint8Array(3);
                const setTypeView = new DataView(setTypeData.buffer);
                setTypeView.setUint8(0, slot);
                setTypeView.setUint16(1, TagType.NTAG_215, false);
                await this.sendCommand(CMD_SET_SLOT_TAG_TYPE, setTypeData);

                // Set slot data to default for NTAG_215
                const setDefaultData = new Uint8Array(3);
                const setDefaultView = new DataView(setDefaultData.buffer);
                setDefaultView.setUint8(0, slot);
                setDefaultView.setUint16(1, TagType.NTAG_215, false);
                await this.sendCommand(CMD_SET_SLOT_DATA_DEFAULT, setDefaultData);

                // Extract UID data for later anti-collision setup
                const page0 = binData.slice(0, 4);   // [uid0, uid1, uid2, BCC0]
                const page1 = binData.slice(4, 8);   // [uid3, uid4, uid5, uid6]

                console.log('Page 0 data:', Array.from(page0).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                console.log('Page 1 data:', Array.from(page1).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                console.log('Expected UID: 04 CE DB BA 79 11 90');

                // Store for anti-collision setup after page writing
                const fullUidWithBcc = new Uint8Array(8);
                fullUidWithBcc.set(page0, 0);       // Copy page 0
                fullUidWithBcc.set(page1, 4);       // Copy page 1

                // Use provided version data or default NTAG215 version
                const actualVersionData = versionData || new Uint8Array([0, 4, 4, 2, 1, 0, 17, 3]);
                console.log('Setting version data:', Array.from(actualVersionData).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                await this.setVersionData(actualVersionData);

                // Set NTAG215 write mode to normal for proper emulation
                try {
                    const writeMode = 0; // 0 = normal, 1 = denied, 2 = deceive, 3 = shadow
                    await this.sendCommand(CMD_MF0_NTAG_SET_WRITE_MODE, new Uint8Array([writeMode]));
                    console.log('Set NTAG write mode to normal');
                } catch (e) {
                    console.log('NTAG write mode command failed:', e.message);
                }

                // Disable UID magic mode for normal NTAG215 emulation
                try {
                    await this.sendCommand(CMD_MF0_NTAG_SET_UID_MAGIC_MODE, new Uint8Array([0])); // 0 = disabled
                    console.log('Disabled UID magic mode');
                } catch (e) {
                    console.log('UID magic mode command failed:', e.message);
                }

                // Set signature data (GUI sets this even if all zeros)
                const slotSignatureData = new Uint8Array(32); // All zeros like in slot.json
                await this.setSignatureData(slotSignatureData);
                console.log('Set signature data (32 zero bytes)');

                // Also set ECC signature data from file if provided
                if (signatureData && signatureData.length === 32) {
                    await this.setSignatureData(signatureData);
                    console.log('Set ECC signature data from file');
                }

                // Enable password authentication for the emulated NTAG215
                // Extract password from the patched data (pages 133-134)
                const passwordBytes = binData.slice(532, 536); // PWD
                const packBytes = binData.slice(536, 538);     // PACK

                // Configure password authentication (if supported by firmware)
                try {
                    // This might need specific command for NTAG password setup
                    // The password is at page 133 (bytes 532-535)
                    console.log('Setting NTAG215 password:', Array.from(passwordBytes).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                    console.log('Setting NTAG215 PACK:', Array.from(packBytes).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                } catch (e) {
                    console.log('Password setup not available in this firmware version');
                }

                // Write all 135 pages directly from the .bin file
                // The command format is: [start_page, num_pages, ...page_data]
                for (let page = 0; page < 135; page++) {
                    try {
                        let pageData = binData.slice(page * 4, (page + 1) * 4);
                        // Ensure we have exactly 4 bytes
                        if (pageData.length < 4) {
                            const paddedData = new Uint8Array(4);
                            paddedData.set(pageData);
                            pageData = paddedData;
                        }
                        const writeData = new Uint8Array(2 + pageData.length);
                        writeData[0] = page;
                        writeData[1] = 1; // Write 1 page at a time
                        writeData.set(pageData, 2);

                        await this.sendCommand(CMD_MF0_NTAG_WRITE_EMU_PAGE_DATA, writeData);

                        // Add small delay every 10 pages to prevent overwhelming the device
                        if (page % 10 === 0) {
                            console.log(`Writing page ${page}/135`);
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                    } catch (error) {
                        console.error(`Failed to write page ${page}:`, error);
                        throw new Error(`Failed to write page ${page}: ${error.message}`);
                    }
                }

                // NOW set up anti-collision AFTER all page data is written
                // Extract UID properly: skip BCC at position 3
                const uidForAntiColl = new Uint8Array(7);
                uidForAntiColl[0] = fullUidWithBcc[0]; // uid0
                uidForAntiColl[1] = fullUidWithBcc[1]; // uid1
                uidForAntiColl[2] = fullUidWithBcc[2]; // uid2
                uidForAntiColl[3] = fullUidWithBcc[4]; // uid3 (skip BCC at [3])
                uidForAntiColl[4] = fullUidWithBcc[5]; // uid4
                uidForAntiColl[5] = fullUidWithBcc[6]; // uid5
                uidForAntiColl[6] = fullUidWithBcc[7]; // uid6

                console.log('Setting anti-collision UID:', Array.from(uidForAntiColl).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));

                const atqa = new Uint8Array([0x44, 0x00]); // Standard NTAG215 ATQA - send as [0x44, 0x00] to get exported as [0,68]
                const sak = 0x00; // Standard NTAG215 SAK
                const ats = new Uint8Array([]); // No ATS for NTAG215

                const antiCollData = new Uint8Array(1 + uidForAntiColl.length + atqa.length + 1 + 1 + ats.length);
                let offset = 0;
                antiCollData[offset++] = uidForAntiColl.length; // UID length
                antiCollData.set(uidForAntiColl, offset); offset += uidForAntiColl.length;
                antiCollData.set(atqa, offset); offset += atqa.length;
                antiCollData[offset++] = sak;
                antiCollData[offset++] = ats.length;
                if (ats.length > 0) antiCollData.set(ats, offset);

                console.log('Anti-collision data:', Array.from(antiCollData).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                await this.sendCommand(CMD_MF1_SET_ANTICOLLISION, antiCollData);
                console.log('Anti-collision setup completed after page writing');

                // Enable the slot for HF frequency
                const enableSlotData = new Uint8Array([slot, TagFrequency.HF, 1]); // slot, frequency, enable(1)
                await this.sendCommand(CMD_SET_SLOT_ENABLE, enableSlotData);
                console.log(`✅ Slot ${slot} enabled for HF frequency`);

                // Save the configuration FIRST before setting nickname
                console.log(`💾 Saving slot data configuration...`);
                await this.sendCommand(CMD_SLOT_DATA_CONFIG_SAVE);
                console.log(`✅ Slot data configuration saved`);

                // Add delay to ensure data is saved
                await new Promise(resolve => setTimeout(resolve, 500));

                // Now set the slot nickname AFTER saving the slot data
                console.log(`📝 Setting slot ${slot} (displayed as Slot ${slot + 1} in UI) nickname to: "${name}"`);
                const textEncoder = new TextEncoder();
                let nameBytes = textEncoder.encode(name);

                // Ensure name isn't too long
                const maxNameLength = 32; // Some devices have a 32-byte limit for nicknames
                if (nameBytes.length > maxNameLength) {
                    console.log(`⚠️ Name too long (${nameBytes.length} bytes), truncating to ${maxNameLength} bytes`);
                    // Try to truncate at a character boundary
                    let truncatedName = name.substring(0, maxNameLength);
                    nameBytes = textEncoder.encode(truncatedName);
                    while (nameBytes.length > maxNameLength) {
                        truncatedName = truncatedName.substring(0, truncatedName.length - 1);
                        nameBytes = textEncoder.encode(truncatedName);
                    }
                }

                console.log(`📝 Name bytes (${nameBytes.length}):`, Array.from(nameBytes).map(b => b.toString(16).padStart(2, '0')).join(' '));

                // NEW APPROACH: Try activating the slot first to ensure it's ready
                console.log(`🎯 Activating slot ${slot} before setting nickname...`);
                const activateSlotForNickData = new Uint8Array([slot]);
                await this.sendCommand(CMD_SET_ACTIVE_SLOT, activateSlotForNickData);
                await new Promise(resolve => setTimeout(resolve, 100));

                // Clear any existing nickname first by setting empty name
                console.log(`🧹 Clearing existing nickname...`);
                const clearNameData = new Uint8Array(2);
                clearNameData[0] = slot;
                clearNameData[1] = TagFrequency.HF;
                await this.sendCommand(CMD_SET_SLOT_TAG_NICK, clearNameData);
                await this.sendCommand(CMD_SLOT_DATA_CONFIG_SAVE);
                await new Promise(resolve => setTimeout(resolve, 200));

                // Now set the new nickname
                const setNameData = new Uint8Array(2 + nameBytes.length);
                setNameData[0] = slot;
                setNameData[1] = TagFrequency.HF; // HF frequency
                setNameData.set(nameBytes, 2);

                console.log(`📝 Sending CMD_SET_SLOT_TAG_NICK with data:`, Array.from(setNameData).map(b => b.toString(16).padStart(2, '0')).join(' '));
                await this.sendCommand(CMD_SET_SLOT_TAG_NICK, setNameData);
                console.log(`✅ Slot nickname set successfully`);

                // Save configuration multiple times with longer delays
                console.log(`💾 Saving nickname configuration (attempt 1)...`);
                await this.sendCommand(CMD_SLOT_DATA_CONFIG_SAVE);
                await new Promise(resolve => setTimeout(resolve, 300));

                console.log(`💾 Saving nickname configuration (attempt 2)...`);
                await this.sendCommand(CMD_SLOT_DATA_CONFIG_SAVE);
                await new Promise(resolve => setTimeout(resolve, 300));

                console.log(`💾 Saving nickname configuration (attempt 3)...`);
                await this.sendCommand(CMD_SLOT_DATA_CONFIG_SAVE);
                console.log(`✅ Nickname configuration saved successfully`);

                // Add longer delay to ensure device has processed the nickname setting
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Verify the nickname was saved by reading it back multiple times
                let verificationAttempts = 3;
                for (let attempt = 1; attempt <= verificationAttempts; attempt++) {
                    try {
                        console.log(`🔍 Verifying nickname was saved (attempt ${attempt})...`);
                        const verifyResponse = await this.sendCommand(CMD_GET_SLOT_TAG_NICK, new Uint8Array([slot, TagFrequency.HF]));

                        // The response should be the UTF-8 string directly
                        let savedName = '';
                        if (verifyResponse.byteLength > 0) {
                            savedName = new TextDecoder().decode(new Uint8Array(verifyResponse.buffer, verifyResponse.byteOffset, verifyResponse.byteLength));
                        }

                        console.log(`✅ Verified nickname (attempt ${attempt}): "${savedName}"`);
                        if (savedName && (savedName === name || name.startsWith(savedName))) {
                            console.log(`🎉 Nickname verification successful!`);
                            break;
                        } else {
                            console.warn(`⚠️ Nickname mismatch on attempt ${attempt}! Expected: "${name}", Got: "${savedName}"`);
                            if (attempt < verificationAttempts) {
                                // Try setting it again
                                console.log(`🔄 Retrying nickname setting...`);
                                await this.sendCommand(CMD_SET_SLOT_TAG_NICK, setNameData);
                                await this.sendCommand(CMD_SLOT_DATA_CONFIG_SAVE);
                                await new Promise(resolve => setTimeout(resolve, 500));
                            }
                        }
                    } catch (verifyError) {
                        console.warn(`⚠️ Failed to verify nickname (attempt ${attempt}):`, verifyError.message);
                    }
                }

                console.log(`📝 Slot ${slot} (displayed as Slot ${slot + 1} in UI) setup completed with nickname: "${name}"`);

                // Clear cache for this slot since new data was written
                clearSlotCache(slot);
            }
        }

        async function generateAmiiboData(amiiboDetails, forceRandomUid = false) {
            if (!amiiboTemplate) {
                const response = await fetch('NTAG215_blank_valid_signature.bin');
                const buffer = await response.arrayBuffer();
                amiiboTemplate = new Uint8Array(buffer);
            }

            const data = new Uint8Array(amiiboTemplate);

            // Amiibo ID is amiiboDetails.head + amiiboDetails.tail
            const amiiboId = getAmiiboId(amiiboDetails);
            const idBytes = [];
            for (let i = 0; i < amiiboId.length; i += 2) {
                idBytes.push(parseInt(amiiboId.substring(i, i + 2), 16));
            }
            data.set(idBytes, 84); // Offset 84 for Amiibo ID

            let uid;
            const useRandomUid = forceRandomUid || randomUidToggle.checked;

            if (!useRandomUid && fixedUids[amiiboId]) {
                // Use existing fixed UID for this Amiibo
                uid = fixedUids[amiiboId];
            } else {
                // Generate new UID
                uid = new Uint8Array(7);
                uid[0] = 0x04; // NTAG215 UID starts with 0x04
                for (let i = 1; i < 7; i++) {
                    uid[i] = Math.floor(Math.random() * 256);
                }

                // Store fixed UID if not using random
                if (!useRandomUid) {
                    fixedUids[amiiboId] = uid;
                }
            }

            // Calculate BCC0 and BCC1
            const bcc0 = uid[0] ^ uid[1] ^ uid[2] ^ uid[3];
            const bcc1 = uid[4] ^ uid[5] ^ uid[6] ^ bcc0;

            // Set UID and BCC bytes in the data
            data.set(uid.slice(0, 4), 0); // UID bytes 0-3 at offset 0
            data.set(uid.slice(4, 7), 4); // UID bytes 4-6 at offset 4
            data[7] = bcc0; // BCC0 at offset 7
            data[8] = bcc1; // BCC1 at offset 8

            return { pageData: data, uid: uid };
        }

        // Generate encrypted amiibo data using maboii.js (V3 method)
        // Always generates with a random UID for fresh amiibo files
        async function generateEncryptedAmiiboData(amiiboId) {
            if (!keysLoaded || !maboiiKeys) {
                throw new Error('Retail keys not loaded. Please upload key_retail.bin first.');
            }

            try {
                console.log(`Generating encrypted amiibo: ${amiiboId}`);

                // Create base unpacked data (540 bytes of zeros)
                const unpackedData = new Array(540).fill(0);

                // Generate random UID
                const randomUID = generateRandomUID();
                const bcc0 = calculateBCC0(randomUID);

                console.log(`UID: ${randomUID.map(b => b.toString(16).padStart(2, '0')).join(' ')}`);

                // Set UID in unpacked data (positions 468-475)
                unpackedData[468] = randomUID[0];
                unpackedData[469] = randomUID[1];
                unpackedData[470] = randomUID[2];
                unpackedData[471] = bcc0;
                unpackedData[472] = randomUID[3];
                unpackedData[473] = randomUID[4];
                unpackedData[474] = randomUID[5];
                unpackedData[475] = randomUID[6];

                // Set the magic bytes from AmiiboConverter
                const magicBytes1 = [0x48, 0x0f, 0xe0, 0xf1, 0x10, 0xff, 0xee, 0xa5];
                for (let i = 0; i < magicBytes1.length; i++) {
                    unpackedData[9 + i] = magicBytes1[i];
                }

                // Set more magic bytes at position 520
                const magicBytes2 = [0x01, 0x00, 0x0f, 0xbf, 0x00, 0x00, 0x00, 0x04,
                                    0x5f, 0x00, 0x00, 0x00, 0x4e, 0xdb, 0xf1, 0x28,
                                    0x80, 0x80, 0x00, 0x00];
                for (let i = 0; i < magicBytes2.length; i++) {
                    unpackedData[520 + i] = magicBytes2[i];
                }

                // Set amiibo ID in UNPACKED data at position 476-483 BEFORE packing
                const idBytes = [];
                for (let i = 0; i < amiiboId.length; i += 2) {
                    idBytes.push(parseInt(amiiboId.substr(i, 2), 16));
                }
                for (let i = 0; i < 8; i++) {
                    unpackedData[476 + i] = idBytes[i];
                }

                // Pack the data
                let packedData = await maboii.pack(maboiiKeys, unpackedData);

                // Set magic bytes in PACKED data (they get lost during packing) - V3 FIX
                const packedMagicBytes = [0x48, 0x0f, 0xe0, 0xf1, 0x10, 0xff, 0xee, 0xa5];
                for (let i = 0; i < packedMagicBytes.length; i++) {
                    packedData[9 + i] = packedMagicBytes[i];
                }

                // Fix position 8 (XOR of bytes 4-7)
                packedData[8] = packedData[4] ^ packedData[5] ^ packedData[6] ^ packedData[7];

                // Calculate and set PWD
                const pwd = calculatePWD(packedData);
                packedData[532] = pwd[0];
                packedData[533] = pwd[1];
                packedData[534] = pwd[2];
                packedData[535] = pwd[3];

                // Set PACK
                packedData[536] = 0x80;
                packedData[537] = 0x80;

                console.log('✅ Encrypted amiibo generated successfully');

                // Extract UID for return (first 8 bytes)
                const uid = Array.from(packedData.slice(0, 8));

                return {
                    pageData: new Uint8Array(packedData),
                    uid: uid
                };

            } catch (error) {
                console.error('Error generating encrypted amiibo:', error);
                throw error;
            }
        }

        // Generate random UID
        function generateRandomUID() {
            const uid = new Array(7);
            uid[0] = 0x04; // Standard NFC Type A UID prefix

            // Generate 6 random bytes
            const randomBytes = new Uint8Array(6);
            crypto.getRandomValues(randomBytes);
            for (let i = 1; i < 7; i++) {
                uid[i] = randomBytes[i-1];
            }

            return uid;
        }

        // Note: updateDataWithUID removed - changing UID requires full re-encryption with retail keys

        // Calculate BCC0 for the UID
        function calculateBCC0(uid) {
            return uid[0] ^ uid[1] ^ uid[2] ^ 0x88;
        }

        // Calculate PWD using the correct method (skip BCC0)
        function calculatePWD(packedUID) {
            const uid7 = new Array(7);
            uid7[0] = packedUID[0];
            uid7[1] = packedUID[1];
            uid7[2] = packedUID[2];
            uid7[3] = packedUID[4]; // Skip BCC0 at position 3
            uid7[4] = packedUID[5];
            uid7[5] = packedUID[6];
            uid7[6] = packedUID[7];

            return [
                (0xAA ^ uid7[1] ^ uid7[3]) & 0xFF,
                (0x55 ^ uid7[2] ^ uid7[4]) & 0xFF,
                (0xAA ^ uid7[3] ^ uid7[5]) & 0xFF,
                (0x55 ^ uid7[4] ^ uid7[6]) & 0xFF
            ];
        }

        async function refreshAmiiboSlots(clearCache = false) {
            debugLog('🔄 refreshAmiiboSlots() called');

            if (clearCache) {
                clearSlotCache(); // Clear all cache
                debugLog('🧹 Cleared all slot cache as requested');
            }

            if (!ultra || !ultra.device || !ultra.device.gatt.connected) {
                debugLog('❌ Device not connected, hiding slots');
                amiiboSlotsDiv.style.display = 'none';
                return;
            }

            try {
                debugLog('📡 Getting slot info from device...');
                const responseSlotInfo = await ultra.sendCommand(CMD_GET_SLOT_INFO);
                const slotNames = await ultra.getSlotNames();
                const activeSlot = await ultra.getActiveSlot();
                currentSlotNames = slotNames; // Store slot names globally

                // Parse slot info to identify which slots have Amiibos
                const slotsWithAmiibos = [];
                for (let i = 0; i < 8; i++) {
                    const hfTagType = responseSlotInfo.getUint16(i * 4, false);
                    const slotName = slotNames[i].hfName || '';
                    const hasAmiibo = hfTagType === TagType.NTAG_215 && slotName;
                    if (hasAmiibo) {
                        slotsWithAmiibos.push(i);
                    }
                }

                debugLog('📊 Device data received:');
                debugLog('- Active slot:', activeSlot);
                debugLog('- Slot names:', slotNames);
                debugLog('- Slots with Amiibos:', slotsWithAmiibos);
                debugLog('- Amiibo database size:', allAmiibos.length);

                amiiboSlotsList.innerHTML = '';
                let hasAmiiboSlots = false;

                for (let i = 0; i < 8; i++) {
                    const hfTagType = responseSlotInfo.getUint16(i * 4, false);
                    const slotName = slotNames[i].hfName || '';
                    const isEmpty = !slotsWithAmiibos.includes(i);
                    const isActive = (i === activeSlot);

                    // Create slot card
                    const slotCard = document.createElement('div');
                    slotCard.className = `well slot ${isEmpty ? 'slot-empty' : ''} ${isActive ? 'slot-selected' : ''}`;

                    const slotTitle = document.createElement('div');
                    slotTitle.className = 'slot-title';
                    slotTitle.textContent = `Slot ${i + 1}`;

                    const slotSummary = document.createElement('div');
                    slotSummary.className = 'slot-summary';

                    if (isEmpty) {
                        slotSummary.textContent = 'Empty slot - Import a .bin/.nfc file or generate to add an Amiibo';
                    } else {
                        hasAmiiboSlots = true;

                        // Always set initial display first
                        slotSummary.textContent = slotName + (isActive ? ' (Currently Selected)' : '');

                        // Try to get Amiibo info from device data
                        debugLog(`Slot ${i + 1}: Name="${slotName}", isEmpty=${isEmpty}, allAmiibos.length=${allAmiibos.length}`);

                        // Rich Amiibo info will be loaded by retryAmiiboInfoForAllSlots() after database loads
                    }

                    const slotLinks = document.createElement('ul');
                    slotLinks.className = 'slot-links';

                    // Upload link (always present)
                    const uploadLi = document.createElement('li');
                    const uploadLink = document.createElement('a');
                    uploadLink.href = '#';
                    uploadLink.textContent = 'Upload';

                    // Create hidden file input for this slot
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = '.bin,.nfc';
                    fileInput.className = 'upload-input';
                    fileInput.id = `upload-input-${i}`;

                    uploadLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        openUploadModal(i, isEmpty ? 'Empty' : slotName);
                    });

                    fileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            uploadBinToSlot(file, i);
                        }
                    });

                    uploadLi.appendChild(uploadLink);
                    uploadLi.appendChild(fileInput);
                    slotLinks.appendChild(uploadLi);

                    if (!isEmpty) {
                        // Download link - commented out until feature is implemented
                        /*
                        const downloadLi = document.createElement('li');
                        const downloadLink = document.createElement('a');
                        downloadLink.href = '#';
                        downloadLink.textContent = 'Download';
                        downloadLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            openDownloadModal(i, slotName);
                        });
                        downloadLi.appendChild(downloadLink);
                        slotLinks.appendChild(downloadLi);
                        */

                        // Clear link
                        const clearLi = document.createElement('li');
                        const clearLink = document.createElement('a');
                        clearLink.href = '#';
                        clearLink.textContent = 'Clear';
                        clearLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            openClearSlotModal(i, slotName);
                        });
                        clearLi.appendChild(clearLink);
                        slotLinks.appendChild(clearLi);

                        // Select link
                        const selectLi = document.createElement('li');
                        const selectLink = document.createElement('a');
                        selectLink.href = '#';
                        selectLink.textContent = 'Select';
                        selectLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            selectSlot(i);
                        });
                        selectLi.appendChild(selectLink);
                        slotLinks.appendChild(selectLi);
                    }

                    // Generate link - only available when keys are loaded
                    if (keysLoaded && maboiiKeys) {
                        const generateLi = document.createElement('li');
                        const generateLink = document.createElement('a');
                        generateLink.href = '#';
                        generateLink.textContent = 'Generate';
                        generateLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            openGenerateModal(i, isEmpty ? 'Empty' : slotName);
                        });
                        generateLi.appendChild(generateLink);
                        slotLinks.appendChild(generateLi);
                    }

                    // Randomize UID link - available for non-empty slots and only when keys are loaded
                    if (!isEmpty && keysLoaded && maboiiKeys) {
                        const randomizeUidLi = document.createElement('li');
                        const randomizeUidLink = document.createElement('a');
                        randomizeUidLink.href = '#';
                        randomizeUidLink.textContent = 'Randomize UID';
                        randomizeUidLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            // Extract amiibo ID directly from the card display
                            const slotCard = e.target.closest('.slot');
                            let amiiboId = null;
                            if (slotCard) {
                                const slotSummary = slotCard.querySelector('.slot-summary');
                                if (slotSummary) {
                                    // Look for "Amiibo ID: XXXXXXXXXXXXXXXX" in the HTML content
                                    const match = slotSummary.innerHTML.match(/Amiibo ID:<\/strong>\s*([A-F0-9]{16})/i);
                                    if (match) {
                                        amiiboId = match[1];
                                    }
                                }
                            }
                            randomizeSlotUID(i, slotName, amiiboId);
                        });
                        randomizeUidLi.appendChild(randomizeUidLink);
                        slotLinks.appendChild(randomizeUidLi);

                        // Add Randomize & Emulate link
                        const randomizeEmulateLi = document.createElement('li');
                        const randomizeEmulateLink = document.createElement('a');
                        randomizeEmulateLink.href = '#';
                        randomizeEmulateLink.textContent = 'Randomize & Emulate';
                        randomizeEmulateLink.style.color = '#28a745'; // Green color for emulate actions
                        randomizeEmulateLink.style.display = 'none'; // Hide for now
                        randomizeEmulateLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            randomizeAndEmulate(i, slotName);
                        });
                        randomizeEmulateLi.appendChild(randomizeEmulateLink);
                        slotLinks.appendChild(randomizeEmulateLi);
                    }

                    slotCard.appendChild(slotTitle);
                    slotCard.appendChild(slotSummary);
                    slotCard.appendChild(slotLinks);
                    amiiboSlotsList.appendChild(slotCard);
                }

                amiiboSlotsDiv.style.display = 'block'; // Always show slots section

                // Ensure the visual selection indicators are properly set for the active slot
                updateSlotSelectionIndicators(activeSlot);

                debugLog(`✅ refreshAmiiboSlots() completed. Created ${amiiboSlotsList.children.length} slot cards. Active slot: ${activeSlot}`);
            } catch (error) {
                console.error('❌ Error refreshing Amiibo slots:', error);
                amiiboSlotsDiv.style.display = 'none';
            }
        }

        async function clearSlot(slotIndex) {
            try {
                showUploadProgress(`Clearing slot ${slotIndex + 1}`, 0, 'Removing Amiibo data...', 'Clearing Slot');

                // Clear cache for this slot since we're deleting its data
                clearSlotCache(slotIndex);

                // Delete slot info (this properly removes the slot data)
                updateUploadProgress('Deleting slot data...', 20, 'Removing all Amiibo information');
                const deleteSlotData = new Uint8Array([slotIndex, TagFrequency.HF]);
                await ultra.sendCommand(CMD_DELETE_SLOT_INFO, deleteSlotData);

                // Set the slot nickname to "Empty"
                updateUploadProgress('Updating slot name...', 40, 'Setting slot nickname to "Empty"');
                const textEncoder = new TextEncoder();
                const emptyNameBytes = textEncoder.encode('Empty');
                const clearNameData = new Uint8Array(2 + emptyNameBytes.length);
                clearNameData[0] = slotIndex;
                clearNameData[1] = TagFrequency.HF;
                clearNameData.set(emptyNameBytes, 2);
                await ultra.sendCommand(CMD_SET_SLOT_TAG_NICK, clearNameData);

                // Save the configuration
                updateUploadProgress('Saving configuration...', 60, 'Writing changes to device memory');
                await ultra.sendCommand(CMD_SLOT_DATA_CONFIG_SAVE);

                // Refresh the display, then enhance with rich Amiibo info
                updateUploadProgress('Refreshing display...', 80, 'Updating slot cards');
                await refreshAmiiboSlots();
                if (allAmiibos.length > 0) {
                    await enhanceSlotCardsWithAmiiboInfo();
                }

                updateUploadProgress('Clear complete!', 100, 'Slot has been successfully cleared');
                setTimeout(() => {
                    hideUploadProgress();
                    setUploadStatus(`Successfully cleared slot ${slotIndex + 1}`, 'success');
                }, 1000);
            } catch (error) {
                console.error('Error clearing slot:', error);
                hideUploadProgress();
                setUploadStatus(`Failed to clear slot ${slotIndex + 1}: ${error.message}`, 'error');
            }
        }

        async function selectSlot(slotIndex) {
            try {
                const activateSlotData = new Uint8Array([slotIndex]);
                await ultra.sendCommand(CMD_SET_ACTIVE_SLOT, activateSlotData);

                // Update visual indicators without full refresh
                updateSlotSelectionIndicators(slotIndex);

                setUploadStatus(`Selected slot ${slotIndex + 1}`, 'success');
            } catch (error) {
                console.error('Error selecting slot:', error);
                setUploadStatus(`Failed to select slot: ${error.message}`, 'error');
            }
        }

        function updateSlotSelectionIndicators(newActiveSlotIndex) {
            const slotCards = document.querySelectorAll('.slot');

            slotCards.forEach((card, index) => {
                const summaryElement = card.querySelector('.slot-summary');
                if (!summaryElement) return;

                const isSelected = (index === newActiveSlotIndex);

                // Update card styling
                if (isSelected) {
                    card.classList.remove('slot-empty');
                    card.classList.add('slot-selected');
                } else {
                    card.classList.remove('slot-selected');
                    // Keep other classes as they were
                }

                // Update text content to add/remove "Currently Selected"
                if (summaryElement.innerHTML.includes('<div')) {
                    // Rich content (Amiibo info) - update the name line
                    // Find the name div more specifically - it has font-weight: bold
                    const nameDiv = summaryElement.querySelector('div[style*="font-weight: bold"]');
                    if (nameDiv) {
                        let text = nameDiv.textContent;
                        // Remove old status
                        text = text.replace(' (Currently Selected)', '');
                        // Add new status if selected
                        if (isSelected) {
                            text += ' (Currently Selected)';
                        }
                        nameDiv.textContent = text;
                    }
                } else {
                    // Simple text content - update directly
                    let text = summaryElement.textContent;
                    // Remove old status
                    text = text.replace(' (Currently Selected)', '');
                    // Add new status if selected
                    if (isSelected) {
                        text += ' (Currently Selected)';
                    }
                    summaryElement.textContent = text;
                }

                // Select buttons always show "Select" text - no need to change it
            });
        }

        async function updateSingleSlotAfterUpload(slotIndex, fileName) {
            const slotCards = document.querySelectorAll('.slot');
            const slotCard = slotCards[slotIndex];

            if (!slotCard) return;

            // Update visual styling - no longer empty
            slotCard.classList.remove('slot-empty');

            // Update summary text temporarily
            const summaryElement = slotCard.querySelector('.slot-summary');
            if (summaryElement) {
                summaryElement.textContent = `${fileName} (uploaded)`;
            }

            // Update the links - add Download, Clear, Select links for newly populated slot
            const linksElement = slotCard.querySelector('.slot-links');
            if (linksElement) {
                // Find the upload link (should be first)
                const uploadLi = linksElement.querySelector('li');

                // Check if links need to be added (avoid duplicates)
                // const hasDownload = Array.from(linksElement.querySelectorAll('a')).some(a => a.textContent === 'Download');
                const hasClear = Array.from(linksElement.querySelectorAll('a')).some(a => a.textContent === 'Clear');
                const hasSelect = Array.from(linksElement.querySelectorAll('a')).some(a => a.textContent === 'Select');

                // Add missing links individually
                // Download link - commented out until feature is implemented
                /*
                if (!hasDownload) {
                    const downloadLi = document.createElement('li');
                    const downloadLink = document.createElement('a');
                    downloadLink.href = '#';
                    downloadLink.textContent = 'Download';
                    downloadLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        openDownloadModal(slotIndex, fileName);
                    });
                    downloadLi.appendChild(downloadLink);
                    linksElement.appendChild(downloadLi);
                }
                */

                if (!hasClear) {
                    // Clear link
                    const clearLi = document.createElement('li');
                    const clearLink = document.createElement('a');
                    clearLink.href = '#';
                    clearLink.textContent = 'Clear';
                    clearLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        openClearSlotModal(slotIndex, fileName);
                    });
                    clearLi.appendChild(clearLink);
                    linksElement.appendChild(clearLi);
                }

                if (!hasSelect) {
                    // Select link
                    const selectLi = document.createElement('li');
                    const selectLink = document.createElement('a');
                    selectLink.href = '#';
                    selectLink.textContent = 'Select';
                    selectLink.addEventListener('click', (e) => {
                        e.preventDefault();
                        selectSlot(slotIndex);
                    });
                    selectLi.appendChild(selectLink);
                    linksElement.appendChild(selectLi);
                }
            }

            // Try to get Amiibo info for this specific slot after a short delay
            setTimeout(async () => {
                try {
                    console.log(`🔍 Getting Amiibo info for newly uploaded slot ${slotIndex + 1}...`);
                    const amiiboInfo = await getSlotAmiiboInfo(slotIndex);
                    if (amiiboInfo && amiiboInfo.name && summaryElement) {
                        // Update with rich Amiibo information
                        summaryElement.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                <img src="${amiiboInfo.image}" alt="${amiiboInfo.name}"
                                     style="width: 40px; height: 40px; object-fit: cover; border-radius: 4px; background: #f0f0f0;">
                                <div style="flex: 1;">
                                    <div style="font-weight: bold; color: #333;">${amiiboInfo.name}</div>
                                    <div style="font-size: 0.85em; color: #666;">${amiiboInfo.amiiboSeries}</div>
                                </div>
                            </div>
                            <div style="font-size: 0.8em; color: #888; line-height: 1.3;">
                                <div><strong>Game Series:</strong> ${amiiboInfo.gameSeries}</div>
                                <div><strong>Character:</strong> ${amiiboInfo.character}</div>
                                <div><strong>Release (NA):</strong> ${amiiboInfo.release?.na || 'TBD'}</div>
                                <div><strong>Amiibo ID:</strong> ${amiiboInfo.extractedId}</div>
                            </div>
                        `;
                        // ID is already displayed on card, no need to store separately
                        console.log(`✅ Updated uploaded slot ${slotIndex + 1} with Amiibo info: ${amiiboInfo.name} (ID: ${amiiboInfo.extractedId})`);
                    }
                } catch (error) {
                    console.log(`Could not get Amiibo info for uploaded slot ${slotIndex + 1}:`, error.message);
                }
            }, 1000); // Wait 1 second for upload to settle
        }

        async function uploadBinToSlot(file, slotIndex) {
            if (!ultra || !ultra.device || !ultra.device.gatt.connected) {
                setUploadStatus('Device not connected', 'error');
                return;
            }

            const fileName = file.name.toLowerCase();
            if (!fileName.endsWith('.bin') && !fileName.endsWith('.nfc')) {
                setUploadStatus('Please select a .bin or .nfc file', 'error');
                return;
            }

            try {
                // Show upload progress modal
                showUploadProgress(`Uploading ${file.name} to slot ${slotIndex + 1}`, 20, 'Reading file...', 'Uploading Amiibo');

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const isNfcFile = file.name.toLowerCase().endsWith('.nfc');
                        updateUploadProgress('Processing file...', 40, `Parsing ${isNfcFile ? '.nfc' : '.bin'} file format`);

                        const parsedBin = isNfcFile ? parseNfcFile(e.target.result) : parseBinFile(e.target.result);
                        const fileName = file.name.replace(/\.(bin|nfc)$/i, '');

                        updateUploadProgress('Patching data...', 60, 'Optimizing for Nintendo Switch compatibility');
                        // Patch the Amiibo data for Switch compatibility
                        const patchedData = patchAmiiboData(parsedBin);

                        updateUploadProgress('Writing to device...', 80, `Writing ${patchedData.length} bytes to slot ${slotIndex + 1}`);
                        // Write the patched bin file with signature data if available
                        await ultra.writeBinToSlot(slotIndex, patchedData, fileName, parsedBin.signatureData, parsedBin.ultralightVersion);

                        updateUploadProgress('Upload complete!', 100, 'Amiibo successfully written to device');

                        // Brief delay to show completion
                        setTimeout(() => {
                            hideUploadProgress();
                            const signatureMsg = parsedBin.hasSignature ? ' (with ECC signature)' : '';
                            setUploadStatus(`Successfully uploaded ${file.name} to Slot ${slotIndex + 1}${signatureMsg}!`, 'success');
                        }, 1000);

                        // Update just this slot instead of refreshing all
                        updateSingleSlotAfterUpload(slotIndex, file.name.replace('.bin', ''));

                    } catch (error) {
                        console.error('Upload error:', error);
                        hideUploadProgress();
                        setUploadStatus(`Failed to upload ${file.name}: ${error.message}`, 'error');
                    }
                };
                // Read file based on type
                const isNfcFile = file.name.toLowerCase().endsWith('.nfc');
                if (isNfcFile) {
                    reader.readAsText(file);
                } else {
                    reader.readAsArrayBuffer(file);
                }

            } catch (error) {
                console.error('File read error:', error);
                hideUploadProgress();
                setUploadStatus(`Failed to read file: ${error.message}`, 'error');
            }
        }

        async function loadAmiiboList() {
            if (allAmiibos.length > 0) {
                return; // Already loaded
            }

            try {
                console.log('Loading Amiibo list from API...');
                const response = await fetch('https://www.amiiboapi.com/api/amiibo/');
                const data = await response.json();
                allAmiibos = data.amiibo.map(amiibo => ({
                    id: getAmiiboId(amiibo),
                    ...amiibo
                }));
                console.log(`Loaded ${allAmiibos.length} Amiibos from API`);
            } catch (error) {
                console.error('Error loading Amiibo list:', error);
                setUploadStatus('Failed to load Amiibo database', 'error');
            }
        }

        async function enhanceSlotCardsWithAmiiboInfo() {
            if (!ultra || !ultra.device || !ultra.device.gatt.connected) {
                console.log('Device not connected, skipping Amiibo info enhancement');
                return;
            }

            debugLog('🎨 Enhancing slot cards with rich Amiibo information...');

            // Get slot info to identify which slots have Amiibos (avoid unnecessary activations)
            const responseSlotInfo = await ultra.sendCommand(CMD_GET_SLOT_INFO);
            const slotNames = await ultra.getSlotNames();
            const originalActiveSlot = await ultra.getActiveSlot();

            // Identify slots with Amiibo data
            const slotsWithAmiibos = [];
            for (let i = 0; i < 8; i++) {
                const hfTagType = responseSlotInfo.getUint16(i * 4, false);
                const slotName = slotNames[i].hfName || '';
                const hasAmiibo = hfTagType === TagType.NTAG_215 && slotName;
                if (hasAmiibo) {
                    slotsWithAmiibos.push(i);
                }
            }

            debugLog(`📍 Original active slot: ${originalActiveSlot}`);
            debugLog(`🎯 Slots to enhance: [${slotsWithAmiibos.join(', ')}] (skipping ${8 - slotsWithAmiibos.length} empty slots)`);

            const slotCards = document.querySelectorAll('.slot');

            for (let i = 0; i < slotCards.length; i++) {
                const slotCard = slotCards[i];
                const summaryElement = slotCard.querySelector('.slot-summary');

                // Skip slots that don't have Amiibo data or already have rich content
                if (!slotsWithAmiibos.includes(i) ||
                    (summaryElement && summaryElement.innerHTML.includes('<div'))) {
                    continue;
                }

                debugLog(`🎨 Enhancing slot ${i + 1} with Amiibo info...`);
                try {
                    const amiiboInfo = await getSlotAmiiboInfo(i);
                    if (amiiboInfo && amiiboInfo.name && summaryElement) {
                        // Use the original active slot to determine status (not current, since we're switching slots)
                        const isCurrentlyActive = (i === originalActiveSlot);
                        const statusText = isCurrentlyActive ? ' (Currently Selected)' : '';

                        // Update with rich Amiibo information
                        summaryElement.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                <img src="${amiiboInfo.image}" alt="${amiiboInfo.name}"
                                     style="width: 40px; height: 40px; object-fit: cover; border-radius: 4px; background: #f0f0f0;">
                                <div style="flex: 1;">
                                    <div style="font-weight: bold; color: #333;">${amiiboInfo.name}${statusText}</div>
                                    <div style="font-size: 0.85em; color: #666;">${amiiboInfo.amiiboSeries}</div>
                                </div>
                            </div>
                            <div style="font-size: 0.8em; color: #888; line-height: 1.3;">
                                <div><strong>Game Series:</strong> ${amiiboInfo.gameSeries}</div>
                                <div><strong>Character:</strong> ${amiiboInfo.character}</div>
                                <div><strong>Release (NA):</strong> ${amiiboInfo.release?.na || 'TBD'}</div>
                                <div><strong>Amiibo ID:</strong> ${amiiboInfo.extractedId}</div>
                            </div>
                        `;
                        // ID is already displayed on card, no need to store separately
                        console.log(`✅ Enhanced slot ${i + 1} with rich Amiibo info: ${amiiboInfo.name} (ID: ${amiiboInfo.extractedId})`);
                    }
                } catch (error) {
                    console.log(`Could not get Amiibo info for slot ${i + 1}:`, error.message);
                }
            }

            // Restore the original active slot
            try {
                const activateSlotData = new Uint8Array([originalActiveSlot]);
                await ultra.sendCommand(CMD_SET_ACTIVE_SLOT, activateSlotData);
                debugLog(`🔄 Restored original active slot: ${originalActiveSlot}`);
            } catch (error) {
                debugLog(`Could not restore original active slot ${originalActiveSlot}:`, error.message);
            }
        }

        function extractAmiiboIdFromSlotData(slotData) {
            // Amiibo ID is stored at bytes 84-91 (pages 21-22) in NTAG215 format
            // This is the 8-byte Amiibo ID used to identify the character
            if (!slotData || slotData.length < 92) {
                return null;
            }

            const amiiboIdBytes = slotData.slice(84, 92);
            const amiiboIdHex = Array.from(amiiboIdBytes)
                .map(b => b.toString(16).padStart(2, '0'))
                .join('')
                .toUpperCase();

            return amiiboIdHex;
        }

        function findAmiiboByID(amiiboId) {
            if (!amiiboId || allAmiibos.length === 0) {
                return null;
            }

            // Try to find exact match first
            let amiibo = allAmiibos.find(a => a.id.toUpperCase() === amiiboId.toUpperCase());

            if (!amiibo) {
                // Try partial match on head+tail combination
                const head = amiiboId.substring(0, 8);
                const tail = amiiboId.substring(8, 16);
                amiibo = allAmiibos.find(a =>
                    getAmiiboHead(a).toUpperCase() === head && getAmiiboTail(a).toUpperCase() === tail
                );
            }

            return amiibo;
        }

        async function getSlotAmiiboInfo(slotIndex) {
            try {
                if (!ultra || !ultra.device || !ultra.device.gatt.connected) {
                    console.log(`Device not connected for slot ${slotIndex + 1}`);
                    return null;
                }

                if (allAmiibos.length === 0) {
                    console.log(`Amiibo database not loaded yet for slot ${slotIndex + 1}`);
                    return null;
                }

                // Get current slot name for cache validation
                const slotNames = await ultra.getSlotNames();
                const currentSlotName = slotNames[slotIndex]?.hfName || '';

                debugLog(`Setting slot ${slotIndex + 1} as active to read Amiibo data...`);
                // Set the slot as active to read from it
                const activateSlotData = new Uint8Array([slotIndex]);
                await ultra.sendCommand(CMD_SET_ACTIVE_SLOT, activateSlotData);

                // Small delay to ensure slot is active
                await new Promise(resolve => setTimeout(resolve, 100));

                debugLog(`Reading NTAG pages 21-22 from slot ${slotIndex + 1}...`);
                // Read pages 21-22 (Amiibo ID is at bytes 84-91, which is pages 21-22)
                const pageData = await ultra.readNtagPages(21, 2); // 2 pages = 8 bytes

                debugLog(`Read ${pageData.length} bytes from slot ${slotIndex + 1}:`, Array.from(pageData).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));

                if (pageData.length >= 8) {
                    // Convert to hex string (Amiibo ID format)
                    const amiiboIdHex = Array.from(pageData)
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join('')
                        .toUpperCase();

                    debugLog(`Slot ${slotIndex + 1} extracted Amiibo ID: ${amiiboIdHex}`);

                    // Skip if the ID looks like empty/default data
                    if (amiiboIdHex === '0000000000000000' || amiiboIdHex === 'FFFFFFFFFFFFFFFF') {
                        debugLog(`Slot ${slotIndex + 1} has empty/default Amiibo ID`);
                        return null;
                    }

                    // Check cache first - validate with current device data
                    if (validateCachedSlotData(slotIndex, currentSlotName, amiiboIdHex)) {
                        const cached = getCachedSlotData(slotIndex);
                        debugLog(`🚀 Using cached data for slot ${slotIndex + 1}: ${cached.amiiboDetails.name}`);
                        return {
                            ...cached.amiiboDetails,
                            extractedId: amiiboIdHex
                        };
                    }

                    // Cache miss or invalid - fetch from API
                    debugLog(`🌐 Fetching fresh data from API for slot ${slotIndex + 1}...`);
                    const amiiboInfo = findAmiiboByID(amiiboIdHex);
                    if (amiiboInfo) {
                        console.log(`✓ Found Amiibo match for slot ${slotIndex + 1}: ${amiiboInfo.name}`);

                        // Cache the result
                        setCachedSlotData(slotIndex, currentSlotName, amiiboIdHex, amiiboInfo);

                        return {
                            ...amiiboInfo,
                            extractedId: amiiboIdHex
                        };
                    } else {
                        console.log(`No Amiibo match found for ID ${amiiboIdHex} in slot ${slotIndex + 1}`);
                    }
                } else {
                    console.log(`Not enough data read from slot ${slotIndex + 1} (got ${pageData.length} bytes, expected 8)`);
                }

                return null;
            } catch (error) {
                console.error(`Error reading slot ${slotIndex + 1} data:`, error);
                return null;
            }
        }


        // New function to update selected slot details
        async function updateSelectedSlotDetails() {
            const selectedSlotIndex = parseInt(slotSelect.value, 10);

            if (!selectedSlotDetailsElement) return;

            // If we don't have slot names yet, try to fetch them
            if (!currentSlotNames || currentSlotNames.length === 0) {
                if (ultra && ultra.device && ultra.device.gatt.connected) {
                    try {
                        currentSlotNames = await ultra.getSlotNames();
                    } catch (error) {
                        console.error('Error fetching slot names:', error);
                        selectedSlotDetailsElement.textContent = `Slot ${selectedSlotIndex + 1}: Unable to fetch info`;
                        return;
                    }
                } else {
                    selectedSlotDetailsElement.textContent = `Slot ${selectedSlotIndex + 1}: Not connected`;
                    return;
                }
            }

            // Update the display with the slot information
            if (currentSlotNames && selectedSlotIndex >= 0 && selectedSlotIndex < currentSlotNames.length) {
                const slotInfo = currentSlotNames[selectedSlotIndex];
                const amiiboName = slotInfo.hfName || 'Empty';
                selectedSlotDetailsElement.textContent = `Slot ${selectedSlotIndex + 1}: ${amiiboName}`;
            } else {
                selectedSlotDetailsElement.textContent = `Slot ${selectedSlotIndex + 1}: No info available`;
            }
        }


        connectBtn.addEventListener('click', async () => {
            try {
                showUploadProgress('Connecting to Chameleon Ultra...', 20, 'Searching for Bluetooth device', 'Device Setup');
                ultra = new ChameleonUltra();
                await ultra.connect();

                updateUploadProgress('Connected!', 100, 'Device connected successfully');
                connectBtn.textContent = 'Connected';
                connectBtn.disabled = true;
                refreshSlotsBtn.style.display = 'inline-block';

                // Close progress modal immediately and show success
                setTimeout(() => {
                    hideUploadProgress();
                    setUploadStatus('Connected to Chameleon Ultra', 'success');
                }, 1000);

                // Load slot information and battery info in background (non-blocking)
                setTimeout(async () => {
                    try {
                        // 1. Get battery info and display it
                        const battery = await ultra.getBatteryInfo();
                        updateBatteryDisplay(battery.voltage, battery.percentage);

                        // 2. Display basic slot cards immediately
                        await refreshAmiiboSlots();

                        // 3. Then load Amiibo database and enhance cards with rich info
                        await loadAmiiboList();
                        await enhanceSlotCardsWithAmiiboInfo();
                    } catch (error) {
                        console.error('Error loading slot information:', error);
                        // Don't show error to user since connection was successful
                    }
                }, 1500);

            } catch (error) {
                console.error('Error:', error);
                hideUploadProgress();
                setUploadStatus('Connection Failed', 'error');
            }
        });

        // Refresh slots button functionality
        refreshSlotsBtn.addEventListener('click', async () => {
            if (!ultra || !ultra.device || !ultra.device.gatt.connected) {
                setUploadStatus('Device not connected', 'error');
                return;
            }

            try {
                setUploadStatus('Refreshing slots...', 'info');
                refreshSlotsBtn.disabled = true;
                refreshSlotsBtn.textContent = 'Refreshing...';

                // Update battery info
                const battery = await ultra.getBatteryInfo();
                updateBatteryDisplay(battery.voltage, battery.percentage);

                await refreshAmiiboSlots();
                await loadAmiiboList();
                await enhanceSlotCardsWithAmiiboInfo();

                setUploadStatus('Slots refreshed successfully', 'success');

            } catch (error) {
                console.error('Error refreshing slots:', error);
                setUploadStatus(`Failed to refresh slots: ${error.message}`, 'error');
            } finally {
                refreshSlotsBtn.disabled = false;
                refreshSlotsBtn.textContent = 'Refresh Slots';
            }
        });

        // Auto-generate Amiibo .bin functionality
        const downloadAmiiboBtn = document.getElementById('download-amiibo-btn');

        async function generateAmiiboBin() {
            if (!selectedAmiiboDetails) {
                throw new Error('No Amiibo selected');
            }

            const amiiboId = getAmiiboId(selectedAmiiboDetails);
            const amiiboName = selectedAmiiboDetails.name;

            // Generate Amiibo bin using our legal template + API data
            const generatedBin = createAmiiboFromTemplate(amiiboId, amiiboName);

            console.log('Generated Amiibo bin:', {
                name: amiiboName,
                id: amiiboId,
                uid: generatedBin.info.uidHex,
                password: generatedBin.info.passwordHex,
                encrypted: true // Uses working encrypted template
            });

            return generatedBin;
        }

        downloadAmiiboBtn.addEventListener('click', async () => {
            if (!selectedAmiiboDetails) {
                setStatus('Please select an Amiibo first.', 'error');
                return;
            }

            try {
                setStatus('Generating Amiibo .bin file...');

                const generatedAmiiboBin = await generateAmiiboBin();

                const blob = new Blob([generatedAmiiboBin.template], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                // Clean filename
                const cleanName = generatedAmiiboBin.amiiboName.replace(/[<>:"/\\|?*]/g, '_');
                a.download = `${cleanName}_[${generatedAmiiboBin.amiiboId.substring(4, 12)}]_Legal.bin`;

                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                setStatus(`Downloaded legal Amiibo .bin for ${generatedAmiiboBin.amiiboName}!`, 'success');

            } catch (error) {
                console.error('Download error:', error);
                setStatus(`Failed to generate/download Amiibo .bin: ${error.message}`, 'error');
            }
        });

        writeBtn.addEventListener('click', async () => {
            if (!selectedAmiiboDetails) {
                setStatus('Please select an Amiibo.', 'error');
                return;
            }
            const slot = parseInt(slotSelect.value, 10); // Get value from select
            if (slot < 0 || slot > 7) { // Slot values are 0-7
                setStatus('Invalid slot number.', 'error');
                return;
            }
            try {
                showUploadProgress('Generating Amiibo...', 20, 'Creating encrypted amiibo data', 'Writing Amiibo');

                // Generate fresh Amiibo bin
                const generatedAmiiboBin = await generateAmiiboBin();

                updateUploadProgress('Preparing data...', 50, 'Setting unique UID and patching data');
                // Ensure the generated UID is properly embedded in the template data
                // The UID should already be in the template, but let's verify and fix if needed
                const templateData = new Uint8Array(generatedAmiiboBin.template);

                // Calculate BCC values for the UID
                const bcc0 = generatedAmiiboBin.uid[0] ^ generatedAmiiboBin.uid[1] ^ generatedAmiiboBin.uid[2] ^ 0x88;
                const bcc1 = generatedAmiiboBin.uid[3] ^ generatedAmiiboBin.uid[4] ^ generatedAmiiboBin.uid[5] ^ generatedAmiiboBin.uid[6];

                // Set UID in pages 0-1 of the template data
                templateData[0] = generatedAmiiboBin.uid[0]; // UID0
                templateData[1] = generatedAmiiboBin.uid[1]; // UID1
                templateData[2] = generatedAmiiboBin.uid[2]; // UID2
                templateData[3] = bcc0;                      // BCC0
                templateData[4] = generatedAmiiboBin.uid[3]; // UID3
                templateData[5] = generatedAmiiboBin.uid[4]; // UID4
                templateData[6] = generatedAmiiboBin.uid[5]; // UID5
                templateData[7] = generatedAmiiboBin.uid[6]; // UID6
                templateData[8] = bcc1;                      // BCC1

                console.log('Setting unique UID in template:', generatedAmiiboBin.info.uidHex);

                // Create a patched version for upload
                const binData = {
                    fullData: templateData,
                    uid: generatedAmiiboBin.uid,
                    ultralightVersion: new Uint8Array([0, 4, 4, 2, 1, 0, 17, 3]) // Standard NTAG215 version
                };

                updateUploadProgress('Writing to device...', 90, `Writing ${selectedAmiiboDetails.name} to slot ${slot + 1}`);
                const patchedData = patchAmiiboData(binData);
                await ultra.writeBinToSlot(slot, patchedData, selectedAmiiboDetails.name, null, binData.ultralightVersion);

                updateUploadProgress('Write complete!', 100, 'Legal Amiibo written successfully!');
                setTimeout(() => {
                    hideUploadProgress();
                    closeModal(); // Close modal after successful write
                    setUploadStatus(`Successfully wrote ${selectedAmiiboDetails.name} to slot ${slot + 1}`, 'success');
                }, 1000);
            } catch (error) {
                console.error('Write Error:', error);
                hideUploadProgress();
                setStatus('Write failed.', 'error');
            }
        });

        emulateBtn.addEventListener('click', async () => {
            if (!selectedAmiiboDetails) {
                setStatus('Please select an Amiibo.', 'error');
                return;
            }
            const slot = parseInt(slotSelect.value, 10); // Get value from select
            if (slot < 0 || slot > 7) { // Slot values are 0-7
                setStatus('Invalid slot number.', 'error');
                return;
            }
            try {
                showUploadProgress('Generating Amiibo...', 20, 'Creating encrypted amiibo data', 'Emulating Amiibo');

                updateUploadProgress('Processing amiibo data...', 50, 'Creating emulation template');
                // Generate fresh Amiibo bin
                const generatedAmiiboBin = await generateAmiiboBin();

                updateUploadProgress('Starting emulation...', 90, `Emulating ${selectedAmiiboDetails.name} on slot ${slot + 1}`);
                await ultra.emulateNtag215(slot, generatedAmiiboBin.template, generatedAmiiboBin.uid);

                updateUploadProgress('Emulation started!', 100, 'Legal Amiibo emulation is active!');
                setTimeout(() => {
                    hideUploadProgress();
                    closeModal(); // Close modal after successful emulate
                    setUploadStatus(`Successfully started emulating ${selectedAmiiboDetails.name} on slot ${slot + 1}`, 'success');
                }, 1000);
            } catch (error) {
                console.error('Emulation Error:', error);
                hideUploadProgress();
                setStatus('Emulation failed.', 'error');
            }
        });

        // Event listener for random UID toggle
        randomUidToggle.addEventListener('change', () => {
            localStorage.setItem('randomUidEnabled', randomUidToggle.checked);
            // Clear fixed UIDs when switching to random mode
            if (randomUidToggle.checked) {
                fixedUids = {};
            }
        });

        // Event listener for slot select change
        slotSelect.addEventListener('change', updateSelectedSlotDetails);

        // Event listeners for slot modal random UID toggle
        slotRandomUidToggle.addEventListener('change', () => {
            // Sync with main toggle preference
            localStorage.setItem('randomUidEnabled', slotRandomUidToggle.checked);
            randomUidToggle.checked = slotRandomUidToggle.checked;
            // Clear fixed UIDs when switching to random mode
            if (slotRandomUidToggle.checked) {
                fixedUids = {};
            }
        });

        // Event listener for upload modal random UID toggle
        uploadRandomizeUid.addEventListener('change', () => {
            // Sync with main toggle preference
            localStorage.setItem('randomUidEnabled', uploadRandomizeUid.checked);
            randomUidToggle.checked = uploadRandomizeUid.checked;
            slotRandomUidToggle.checked = uploadRandomizeUid.checked;
        });

        // Event listeners for slot modal buttons
        slotWriteBtn.addEventListener('click', async () => {
            if (!selectedSlotAmiiboDetails || selectedSlotIndex === null) {
                setSlotStatus('No slot selected.', 'error');
                return;
            }

            try {
                setSlotStatus('Generating and writing...');
                const forceRandom = slotRandomUidToggle.checked;
                const { pageData, uid } = await generateAmiiboData(selectedSlotAmiiboDetails, forceRandom);
                await ultra.writeNtag215ToSlot(selectedSlotIndex, pageData, uid, selectedSlotAmiiboDetails.name);
                setSlotStatus('Write successful!', 'success');
                await refreshAmiiboSlots(); // Refresh slots after write
                if (allAmiibos.length > 0) {
                    await enhanceSlotCardsWithAmiiboInfo();
                }
                closeSlotModal(); // Close modal after successful write
            } catch (error) {
                console.error('Write Error:', error);
                setSlotStatus('Write failed.', 'error');
            }
        });

        slotEmulateBtn.addEventListener('click', async () => {
            if (!selectedSlotAmiiboDetails || selectedSlotIndex === null) {
                setSlotStatus('No slot selected.', 'error');
                return;
            }

            try {
                setSlotStatus('Generating and emulating...');
                const forceRandom = slotRandomUidToggle.checked;
                const { pageData, uid } = await generateAmiiboData(selectedSlotAmiiboDetails, forceRandom);
                await ultra.emulateNtag215(selectedSlotIndex, pageData, uid);
                setSlotStatus('Emulation started!', 'success');
                await refreshAmiiboSlots(); // Refresh slots after emulate
                if (allAmiibos.length > 0) {
                    await enhanceSlotCardsWithAmiiboInfo();
                }
                closeSlotModal(); // Close modal after successful emulate
            } catch (error) {
                console.error('Emulation Error:', error);
                setSlotStatus('Emulation failed.', 'error');
            }
        });


        // Event listeners for slot modal close
        slotCloseButton.addEventListener('click', closeSlotModal);
        window.addEventListener('click', (event) => {
            if (event.target == slotModal) {
                closeSlotModal();
            }
        });


        // Template generation functionality
        // Removed template functionality - elements don't exist anymore

        // Template generation removed - all related code commented out

        /*
        let currentTemplate = null;

        generateTemplateBtn.addEventListener('click', () => {
            try {
                currentTemplate = createNTAG215WithUID();

                templateInfo.innerHTML = `
                    <strong>Generated Legal NTAG215 Template:</strong><br>
                    Type: ${currentTemplate.info.type}<br>
                    Size: ${currentTemplate.info.size} bytes<br>
                    UID: ${currentTemplate.info.uidHex}<br>
                    Password: ${currentTemplate.info.passwordHex}<br>
                    <br>
                    <strong>Structure Verification:</strong><br>
                    CC (Page 3): ${Array.from(currentTemplate.template.slice(12, 16)).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}<br>
                    AUTH0: 0x${currentTemplate.template[527].toString(16).padStart(2, '0')}<br>
                    ACCESS: 0x${currentTemplate.template[528].toString(16).padStart(2, '0')}<br>
                    <br>
                    <em>This template contains no copyrighted data and is based on public NXP NTAG215 specifications.</em>
                `;

                downloadTemplateBtn.style.display = 'inline-block';
                uploadTemplateBtn.style.display = ultra ? 'inline-block' : 'none';

            } catch (error) {
                templateInfo.innerHTML = `<span style="color: red;">Error generating template: ${error.message}</span>`;
            }
        });

        downloadTemplateBtn.addEventListener('click', () => {
            if (!currentTemplate) {
                showNotification('Generate a template first!', 'warning');
                return;
            }

            const blob = new Blob([currentTemplate.template], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ntag215-blank-${currentTemplate.info.uidHex.replace(/\s/g, '').replace(/0x/g, '')}.bin`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        uploadTemplateBtn.addEventListener('click', () => {
            if (!currentTemplate || !ultra) {
                showNotification('Generate a template and connect device first!', 'warning');
                return;
            }

            const slot = parseInt(prompt('Select slot (1-8) to write the blank NTAG215 template to:'));
            if (slot >= 1 && slot <= 8) {
                writeTemplateToSlot(slot - 1);
            } else if (!isNaN(slot)) {
                templateInfo.innerHTML = `<span style="color: red;">Invalid slot number. Please enter 1-8.</span>`;
            }
        });

        async function writeTemplateToSlot(slotIndex) {
            if (!currentTemplate || !ultra) {
                templateInfo.innerHTML = `<span style="color: red;">No template generated or device not connected</span>`;
                return;
            }

            try {
                templateInfo.innerHTML = 'Writing blank NTAG215 template to slot...';

                const templateName = `Blank-NTAG215-${currentTemplate.uid.slice(1, 4).map(b => b.toString(16).padStart(2, '0')).join('')}`;

                // Use our proven upload method but with the template data
                await ultra.writeBinToSlot(slotIndex, currentTemplate.template, templateName, null, new Uint8Array([0, 4, 4, 2, 1, 0, 17, 3]));

                templateInfo.innerHTML = `<span style="color: green;">✅ Blank NTAG215 template written to slot ${slotIndex + 1} successfully!</span>`;

                // Refresh the slots display
                if (typeof loadSlots === 'function') {
                    await refreshAmiiboSlots();
                }

            } catch (error) {
                console.error('Template upload error:', error);
                templateInfo.innerHTML = `<span style="color: red;">❌ Failed to write template: ${error.message}</span>`;
            }
        }
        */

        // Event listener for closing the modal
        closeButton.addEventListener('click', closeModal);
        window.addEventListener('click', (event) => {
            if (event.target == amiiboModal) {
                closeModal();
            }
        });

        // Clear Slot Modal Event Listeners
        clearCloseButton.addEventListener('click', closeClearSlotModal);
        clearCancelBtn.addEventListener('click', closeClearSlotModal);
        clearConfirmBtn.addEventListener('click', async () => {
            const slotIndex = parseInt(clearConfirmBtn.dataset.slotIndex);
            if (!isNaN(slotIndex)) {
                // Close modal immediately and show clearing status
                closeClearSlotModal();
                setUploadStatus(`Clearing slot ${slotIndex + 1}...`);

                // Then execute the clear operation
                await clearSlot(slotIndex);
            }
        });

        // Download Modal Event Listeners
        downloadCloseButton.addEventListener('click', closeDownloadModal);
        downloadCancelBtn.addEventListener('click', closeDownloadModal);

        // Upload Modal Event Listeners
        uploadCloseButton.addEventListener('click', closeUploadModal);
        uploadCancelBtn.addEventListener('click', closeUploadModal);

        uploadConfirmBtn.addEventListener('click', async () => {
            const file = uploadFileInput.files[0];
            if (!file) {
                setUploadModalStatus('Please select a file first', 'error');
                return;
            }

            if (uploadTargetSlot === null) {
                setUploadModalStatus('No target slot selected', 'error');
                return;
            }

            try {
                // Store slot before closing modal since closeUploadModal sets it to null
                const targetSlot = uploadTargetSlot;

                // Close the upload modal and show progress modal instead
                closeUploadModal();

                showUploadProgress('Preparing upload...', 20, 'Processing file selection', 'Uploading Amiibo');

                // Use the existing uploadBinToSlot function with randomize option
                // Force randomization to false if no keys are available
                const shouldRandomize = uploadRandomizeUid.checked && keysLoaded && maboiiKeys;
                await uploadBinToSlotWithRandomize(file, targetSlot, shouldRandomize);

            } catch (error) {
                console.error('Upload error:', error);
                hideUploadProgress();
                setUploadStatus(`Upload failed: ${error.message}`, 'error');
            }
        });

        // Upload & Emulate button event listener
        uploadEmulateBtn.addEventListener('click', async () => {
            const file = uploadFileInput.files[0];
            if (!file) {
                setUploadModalStatus('Please select a file first', 'error');
                return;
            }

            if (uploadTargetSlot === null) {
                setUploadModalStatus('No target slot selected', 'error');
                return;
            }

            try {
                // Store slot before closing modal since closeUploadModal sets it to null
                const targetSlot = uploadTargetSlot;

                // Close the upload modal and show progress modal instead
                closeUploadModal();

                showUploadProgress('Preparing emulation...', 20, 'Processing file selection', 'Uploading & Emulating Amiibo');

                // Use the existing upload function but with emulate instead of write
                // Force randomization to false if no keys are available
                const shouldRandomize = uploadRandomizeUid.checked && keysLoaded && maboiiKeys;
                await uploadAndEmulateToSlot(file, targetSlot, shouldRandomize);

            } catch (error) {
                console.error('Upload & Emulate error:', error);
                hideUploadProgress();
                setUploadStatus(`Upload & emulate failed: ${error.message}`, 'error');
            }
        });

        async function uploadAndEmulateToSlot(file, slot, randomize = false) {
            const fileExtension = file.name.split('.').pop().toLowerCase();
            let parsedData;

            updateUploadProgress('Parsing file...', 40, `Processing ${fileExtension.toUpperCase()} file`);

            if (fileExtension === 'bin') {
                const arrayBuffer = await file.arrayBuffer();
                parsedData = parseBinFile(arrayBuffer);
            } else if (fileExtension === 'nfc') {
                const text = await file.text();
                parsedData = parseNfcFile(text);
            } else {
                throw new Error(`Unsupported file type: ${fileExtension}`);
            }

            let finalData = parsedData.fullData;
            let uid = parsedData.uid;
            let name = file.name.replace(/\.[^/.]+$/, ""); // Remove extension

            // Only attempt randomization if keys are available
            if (randomize) {
                if (!keysLoaded || !maboiiKeys) {
                    throw new Error('Retail keys are required for UID randomization');
                }

                updateUploadProgress('Randomizing UID...', 60, 'Re-encrypting with new random UID');

                // Extract amiibo ID for re-encryption
                const amiiboIdHex = extractAmiiboIdFromBinData(finalData);
                if (!amiiboIdHex || amiiboIdHex === '0000000000000000') {
                    throw new Error('Cannot extract amiibo ID for re-encryption');
                }

                // Generate completely new encrypted amiibo with same ID but new UID
                const generatedData = await generateEncryptedAmiiboData(amiiboIdHex);
                finalData = generatedData.pageData;
                uid = generatedData.uid;
                name += ` (New UID)`;
            }

            updateUploadProgress('Starting emulation...', 90, `Emulating ${name} on slot ${slot + 1}`);
            await ultra.emulateNtag215(slot, finalData, uid);

            updateUploadProgress('Emulation started!', 100, 'Amiibo emulation is now active!');

            setTimeout(() => {
                hideUploadProgress();
                setUploadStatus(`Successfully started emulating ${name} on slot ${slot + 1}`, 'success');
                refreshAmiiboSlots(); // Refresh slots after emulate
            }, 1500);
        }

        // Key management event handlers
        keyFileInput.addEventListener('change', loadKeysFromFile);
        clearKeysBtn.addEventListener('click', clearKeys);

        // Generate Modal Event Listeners
        generateCloseButton.addEventListener('click', closeGenerateModal);
        generateCancelBtn.addEventListener('click', closeGenerateModal);

        // Amiibo search functionality
        let searchTimeout = null;
        let gameSeriesSet = new Set();

        amiiboSearch.addEventListener('input', (e) => {
            const query = e.target.value.trim();

            if (searchTimeout) clearTimeout(searchTimeout);

            searchTimeout = setTimeout(() => {
                performSearch(query);
            }, 300);
        });

        gameSeriesFilter.addEventListener('change', () => performSearch());
        sortOption.addEventListener('change', () => performSearch());

        clearFiltersBtn.addEventListener('click', () => {
            // Clear search filters
            amiiboSearch.value = '';
            gameSeriesFilter.value = '';
            sortOption.value = 'newest';

            // Clear selected amiibo
            selectedAmiiboForGeneration = null;
            document.getElementById('selected-amiibo-section').style.display = 'none';

            // Clear previous selections in cards
            document.querySelectorAll('.recent-amiibo-card, .favorite-amiibo-card').forEach(c => c.classList.remove('selected'));

            // Reload and refresh the recent/favorites lists
            loadRecentAmiibos();
            loadFavoriteAmiibos();
            displayRecentAmiibos();
            displayFavoriteAmiibos();

            // Load amiibo database and show all amiibos like at modal load
            loadAmiiboDatabase().then(() => {
                performSearch(''); // Show all amiibos with results visible
            });
        });

        let allAmiiboData = [];

        // Amiibo database caching
        let amiiboDataCache = {
            data: [],
            gameSeriesList: [],
            lastFetched: null,
            cacheExpiry: 30 * 60 * 1000 // 30 minutes in milliseconds
        };

        function isCacheValid() {
            if (!amiiboDataCache.lastFetched) return false;
            const now = Date.now();
            const isValid = (now - amiiboDataCache.lastFetched) < amiiboDataCache.cacheExpiry;
            if (!isValid) {
                debugLog('🕒 Amiibo cache expired, will fetch fresh data');
            }
            return isValid;
        }

        function setCachedAmiiboData(data) {
            // Build game series list
            gameSeriesSet.clear();
            data.forEach(amiibo => gameSeriesSet.add(amiibo.gameSeries));
            const sortedSeries = Array.from(gameSeriesSet).sort();

            // Update cache
            amiiboDataCache.data = data;
            amiiboDataCache.gameSeriesList = sortedSeries;
            amiiboDataCache.lastFetched = Date.now();

            // Update global variables
            allAmiiboData = data;

            debugLog(`💾 Cached ${data.length} amiibos with ${sortedSeries.length} game series`);
        }

        function getCachedAmiiboData() {
            if (isCacheValid() && amiiboDataCache.data.length > 0) {
                debugLog(`🚀 Using cached amiibo data (${amiiboDataCache.data.length} amiibos)`);

                // Restore global variables from cache
                allAmiiboData = amiiboDataCache.data;
                gameSeriesSet.clear();
                amiiboDataCache.gameSeriesList.forEach(series => gameSeriesSet.add(series));

                return true;
            }
            return false;
        }

        async function loadAmiiboDatabase() {
            // Try to use cached data first
            if (getCachedAmiiboData()) {
                // Populate dropdown from cache
                populateGameSeriesDropdown();
                return Promise.resolve();
            }

            // Cache miss or expired - fetch from API
            try {
                debugLog('🌐 Fetching fresh amiibo data from API...');
                const response = await fetch('https://www.amiiboapi.com/api/amiibo/');
                const data = await response.json();

                // Cache the fresh data
                setCachedAmiiboData(data.amiibo);

                // Populate dropdown
                populateGameSeriesDropdown();

                debugLog(`✅ Loaded ${data.amiibo.length} amiibos from API`);
            } catch (error) {
                debugError('Error loading amiibo database:', error);
            }
            return Promise.resolve();
        }

        function populateGameSeriesDropdown() {
            gameSeriesFilter.innerHTML = '<option value="">All Game Series</option>';
            amiiboDataCache.gameSeriesList.forEach(series => {
                const option = document.createElement('option');
                option.value = series;
                option.textContent = series;
                gameSeriesFilter.appendChild(option);
            });
        }

        function clearAmiiboCache() {
            amiiboDataCache.data = [];
            amiiboDataCache.gameSeriesList = [];
            amiiboDataCache.lastFetched = null;
            allAmiiboData = [];
            gameSeriesSet.clear();
            debugLog('🗑️ Cleared amiibo database cache');
        }

        function performSearch(query = null) {
            if (query === null) query = amiiboSearch.value.trim();

            if (allAmiiboData.length === 0) {
                loadAmiiboDatabase().then(() => performSearch(query));
                return;
            }

            // Always show results when modal is open
            // Empty query shows all amiibos

            let filteredAmiibos = allAmiiboData;

            // Apply text search filter
            if (query.length > 0) {
                filteredAmiibos = filteredAmiibos.filter(amiibo =>
                    amiibo.name.toLowerCase().includes(query.toLowerCase()) ||
                    amiibo.amiiboSeries.toLowerCase().includes(query.toLowerCase()) ||
                    amiibo.gameSeries.toLowerCase().includes(query.toLowerCase())
                );
            }

            // Apply game series filter
            if (gameSeriesFilter.value) {
                filteredAmiibos = filteredAmiibos.filter(amiibo =>
                    amiibo.gameSeries === gameSeriesFilter.value
                );
            }

            // Apply sorting
            const sort = sortOption.value;
            filteredAmiibos.sort((a, b) => {
                switch (sort) {
                    case 'newest':
                        return compareNewestFirst(a, b);
                    case 'oldest':
                        return compareOldestFirst(a, b);
                    default:
                        return compareNewestFirst(a, b);
                }
            });

            // Limit results
            filteredAmiibos = filteredAmiibos.slice(0, 50);
            displaySearchResults(filteredAmiibos);
        }

        function compareDates(dateA, dateB) {
            // Handle null/undefined dates
            if (!dateA && !dateB) return 0;
            if (!dateA) return 1;
            if (!dateB) return -1;

            const a = new Date(dateA);
            const b = new Date(dateB);
            return a - b;
        }

        function getEarliestReleaseDate(amiibo) {
            // Get the earliest available release date (prioritize NA -> EU -> JP)
            const dates = [
                amiibo.release.na,
                amiibo.release.eu,
                amiibo.release.jp,
                amiibo.release.au
            ].filter(date => date && date !== 'null');

            if (dates.length === 0) return null;

            // Return the earliest date
            return dates.reduce((earliest, current) => {
                const earliestDate = new Date(earliest);
                const currentDate = new Date(current);
                return currentDate < earliestDate ? current : earliest;
            });
        }

        function compareNewestFirst(a, b) {
            const dateA = getEarliestReleaseDate(a);
            const dateB = getEarliestReleaseDate(b);

            // Handle null dates (put them at the end)
            if (!dateA && !dateB) return 0;
            if (!dateA) return 1;
            if (!dateB) return -1;

            // Newest first (reverse chronological)
            return new Date(dateB) - new Date(dateA);
        }

        function compareOldestFirst(a, b) {
            const dateA = getEarliestReleaseDate(a);
            const dateB = getEarliestReleaseDate(b);

            // Handle null dates (put them at the end)
            if (!dateA && !dateB) return 0;
            if (!dateA) return 1;
            if (!dateB) return -1;

            // Oldest first (chronological)
            return new Date(dateA) - new Date(dateB);
        }

        function displaySearchResults(amiibos) {
            const resultsDiv = amiiboSearchResults;
            resultsDiv.innerHTML = '';

            // Show results count
            resultsInfo.textContent = `${amiibos.length} amiibo${amiibos.length === 1 ? '' : 's'} found`;
            resultsInfo.style.display = 'block';

            if (amiibos.length === 0) {
                resultsDiv.innerHTML = '<div style="padding: 10px; text-align: center; color: #666;">No amiibos found</div>';
                resultsDiv.style.display = 'block';
                return;
            }

            amiibos.forEach(amiibo => {
                const resultItem = document.createElement('div');
                resultItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    padding: 10px;
                    border-bottom: 1px solid #eee;
                    cursor: pointer;
                    transition: background-color 0.2s;
                `;
                resultItem.addEventListener('mouseenter', () => {
                    resultItem.style.backgroundColor = '#f5f5f5';
                });
                resultItem.addEventListener('mouseleave', () => {
                    resultItem.style.backgroundColor = 'white';
                });
                resultItem.addEventListener('click', () => {
                    selectAmiiboForGeneration(amiibo);
                });

                // Format release date for display
                let releaseInfo = '';
                if (amiibo.release.na && amiibo.release.na !== 'null') {
                    releaseInfo = `NA: ${amiibo.release.na}`;
                } else if (amiibo.release.eu && amiibo.release.eu !== 'null') {
                    releaseInfo = `EU: ${amiibo.release.eu}`;
                } else if (amiibo.release.jp && amiibo.release.jp !== 'null') {
                    releaseInfo = `JP: ${amiibo.release.jp}`;
                }

                resultItem.innerHTML = `
                    <img src="${amiibo.image}" alt="${amiibo.name}"
                         style="width: 50px; height: 50px; object-fit: cover; margin-right: 12px; border-radius: 4px;">
                    <div style="flex: 1;">
                        <div style="font-weight: bold; margin-bottom: 2px;">${amiibo.name}</div>
                        <div style="color: #666; font-size: 0.9em; margin-bottom: 1px;">${amiibo.amiiboSeries}</div>
                        <div style="color: #888; font-size: 0.85em; margin-bottom: 1px;">${amiibo.gameSeries}</div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="color: #999; font-size: 0.8em; font-family: monospace;">${getAmiiboId(amiibo)}</div>
                            ${releaseInfo ? `<div style="color: #007bff; font-size: 0.8em;">${releaseInfo}</div>` : ''}
                        </div>
                    </div>
                `;

                resultsDiv.appendChild(resultItem);
            });

            resultsDiv.style.display = 'block';
        }

        // Generate action button
        generateWriteBtn.addEventListener('click', async () => {
            if (!selectedAmiiboForGeneration) {
                console.log('No amiibo selected for generation');
                return;
            }
            await generateAndWriteAmiibo();
        });

        // Generate & Emulate button event listener
        generateEmulateBtn.addEventListener('click', async () => {
            if (!selectedAmiiboForGeneration) {
                console.log('No amiibo selected for emulation');
                return;
            }
            await generateAndEmulateAmiibo();
        });

        async function generateAndEmulateAmiibo() {
            try {
                showUploadProgress('Generating amiibo...', 20, 'Creating encrypted amiibo data', 'Generating & Emulating Amiibo');

                updateUploadProgress('Processing amiibo data...', 50, 'Encrypting amiibo information');
                // Generate the amiibo data using our V3 method (always uses random UID)
                const amiiboId = getAmiiboId(selectedAmiiboForGeneration);
                const generatedData = await generateEncryptedAmiiboData(amiiboId);

                updateUploadProgress('Starting emulation...', 90, `Emulating ${selectedAmiiboForGeneration.name} on slot ${generateTargetSlot + 1}`);
                // Use emulateNtag215 instead of writeBinToSlot
                await ultra.emulateNtag215(generateTargetSlot, generatedData.pageData, generatedData.uid);

                updateUploadProgress('Emulation started!', 100, 'Generated Amiibo emulation is now active!');

                // Store values before closing modal since closeGenerateModal() sets them to null
                const amiiboName = selectedAmiiboForGeneration.name;
                const slotNumber = generateTargetSlot + 1;

                setTimeout(() => {
                    hideUploadProgress();
                    closeGenerateModal();
                    setUploadStatus(`Successfully started emulating ${amiiboName} on slot ${slotNumber}`, 'success');
                    refreshAmiiboSlots(); // Refresh slots after emulate
                }, 1500);

            } catch (error) {
                console.error('Generate & Emulate error:', error);
                hideUploadProgress();
            }
        }

        async function generateAndWriteAmiibo() {
            try {
                showUploadProgress('Generating amiibo...', 20, 'Creating encrypted amiibo data', 'Generating Amiibo');

                updateUploadProgress('Processing amiibo data...', 50, 'Encrypting amiibo information');
                // Generate the amiibo data using our V3 method (always uses random UID)
                const amiiboId = getAmiiboId(selectedAmiiboForGeneration);
                console.log(`🎮 Generating amiibo: "${selectedAmiiboForGeneration.name}" with ID: ${amiiboId}`);
                const generatedData = await generateEncryptedAmiiboData(amiiboId);

                // Verify the generated data contains the correct Amiibo ID
                const generatedAmiiboId = Array.from(generatedData.pageData.slice(84, 92)).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();
                console.log(`🔍 Generated data contains Amiibo ID: ${generatedAmiiboId}`);
                if (generatedAmiiboId !== amiiboId.toUpperCase()) {
                    console.error(`❌ Amiibo ID mismatch! Expected: ${amiiboId.toUpperCase()}, Got: ${generatedAmiiboId}`);
                }

                updateUploadProgress('Writing to device...', 90, `Writing ${selectedAmiiboForGeneration.name} to slot ${generateTargetSlot + 1}`);
                // Use writeBinToSlot like the working amiibo uploads
                await ultra.writeBinToSlot(generateTargetSlot, generatedData.pageData, selectedAmiiboForGeneration.name, null, new Uint8Array([0, 4, 4, 2, 1, 0, 17, 3]));

                updateUploadProgress('Generation complete!', 100, 'Amiibo written to slot successfully!');

                // Save to recent amiibos
                saveRecentAmiibo(selectedAmiiboForGeneration);

                // Store values before closing modal since closeGenerateModal() sets them to null
                const amiiboName = selectedAmiiboForGeneration.name;
                const slotNumber = generateTargetSlot + 1;

                // Close progress modal and generate modal immediately, show success
                setTimeout(() => {
                    hideUploadProgress();
                    closeGenerateModal();
                    setUploadStatus(`Successfully generated ${amiiboName} to slot ${slotNumber}`, 'success');
                }, 1000);

                // Refresh the slots display in background (non-blocking)
                setTimeout(async () => {
                    await refreshAmiiboSlots();
                    if (allAmiibos.length > 0) {
                        await enhanceSlotCardsWithAmiiboInfo();
                    }
                }, 1500);

            } catch (error) {
                console.error('Generation error:', error);
                hideUploadProgress();
            }
        }

        // Close modals when clicking outside
        window.addEventListener('click', (event) => {
            if (event.target == clearSlotModal) {
                closeClearSlotModal();
            }
            if (event.target == downloadModal) {
                closeDownloadModal();
            }
            if (event.target == uploadModal) {
                closeUploadModal();
            }
            if (event.target == generateModal) {
                closeGenerateModal();
            }
        });

        // Initialize keys on page load
        loadStoredKeys();
        updateKeyStatus();

        // Initialize recent amiibos and favorites
        loadRecentAmiibos();
        loadFavoriteAmiibos();

    </script>
</body>
</html>